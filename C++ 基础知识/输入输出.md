### 输入输出
C++ 标准库中，主要有这几类输入输出方式：
- C 风格的输入输出：`scanf`，`printf`，`getchar`，`putchar`，`puts` 等。
- C++ iostream：`cin`，`cout` 等。
- C++23 print：`print`，`println` 等。

#### iostream
`iostream` 头文件提供了 `cin`，`cout` 等用于输入输出的设施。

iostream 采用重载的右移（有时又称“流输入”）和左移（“流输出”）运算符进行输入输出。代码如下：
```cpp
int x;
std::cin >> x;  // 输入
std::cout << x;  // 输出
```

`cout` 可以通过输出一些操纵符，来进行一定程度的格式化输出。大多数操纵符在头文件 `iomanip` 中定义。

以下是部分常用的格式化操纵符。

| 类别 | 描述 |
|---|---|
| 进制控制 | `dec`（十进制）, `hex`（十六进制）, `oct`（八进制） |
| 浮点格式 | 见下文 |
| 定宽输出 | `setw(n)`（设置宽度），`setfill(c)`（设置填充） |
| 对齐方式 | `left`（左对齐），`right`（右对齐） |
| 布尔格式 | `boolalpha`（输出 `true`/`false`），`noboolalpha`（输出 `1`/`0`） |
| 其他 | `flush`（刷新缓冲区），`endl`（换行并刷新）|

浮点格式控制，`fixed` 表示输出固定小数点，`scientific` 表示科学计数法。

`setprecision(n)` 可以设置精度，如果指定 `fixed` 或者 `scientific` 则保留小数点后 $n$ 位，否则为有效数字 $n$ 位。`defaultfloat` 恢复默认格式。

这些影响后续格式的操纵符中，`setw` 和 `setfill` 是一次性的，其他都是持续有效。

例如，如下代码可以保留 2 位小数输出：
```cpp
std::cout << std::fixed << std::setprecision(2) << 3.1415;  // 3.14
```

默认情况下，iostream 的输入输出方式很慢。**可以通过以下代码来加速**：
```cpp
std::ios::sync_with_stdio(false);
std::cin.tie(nullptr);
```
这种方法通常叫做“关闭同步流”，可以大幅度提升 cin 和 cout 的速度。

第一行的原理是，默认情况下 C 风格的输入输出会维护一个缓冲区来加速（即内容不会立即输出到屏幕，而是存到缓冲区中，缓冲区满或者手动刷新再一次性输出）。而 iostream 为了和 C 兼容，会在每一次输入输出时都刷新缓冲区，导致额外开销。调用了 `ios::sync_with_stdio(false)` 之后就不会每次刷新了。

第二行的原理是，默认情况下 cin 会和 cout 互相绑定，在每次使用 cin 输出时都刷新 cout 的缓冲区。这样可以避免交替使用输入输出时的额外刷新开销。

由于 `endl` 会刷新缓冲区，使用 `'\n'` 而不是 `endl` 换行也会加速输出。

经过这样优化的 `cin` 和 `cout`，速度会略快于 `scanf` 和 `printf`。

关闭同步流的情况下，**iostream 和 C 风格输入输出不能混用**。否则可能会导致多次输出的结果乱序。

`cin` 和 `cout` 通过重载运算符输入输出之后，返回值为它本身。

`cin` 和 `cout` 会维护一个状态，表示是否发生错误。`cin.good()` 表示状态一切正常，`cin.eof()` 表示读到文件尾部，`cin.fail()` 和 `cin.bad()` 表示发生了错误。它们可以隐式转换为 `bool`，表示当前是否为 `good`。当 `good` 状态为 `false`，会拒绝接下来的输入输出操作。

例如，可以通过以下代码读入整数，直到遇到 EOF 停止。

```cpp
int ch;
while (cin >> ch) {
    cout << ch;
}
```

#### C 风格输入输出（stdio）
C 风格输入输出通常在 `cstdio` 头文件中定义。

**printf：格式化输出**

```cpp
printf("a = %d, b = %d\n", 1, 2);
```

`printf` 可以提供一个格式字符串，依次填充其中的参数，并进行输出。

格式字符串中，以百分号开头的是一个“参数槽”（转换说明符），将会在后续被实际传入的参数替代。

所有的转换说明符，可以见 [cppreference](https://en.cppreference.com/w/cpp/io/c/printf)。

所有的转换说明符包含以下的部分：

- 前导的 `%` 字符。
- 零个、一个或多个以下修饰符： 
    - `-`：输出结果将会是左对齐（默认为右对齐）。
    - `+`：对于有符号数，总是输出正号（默认不输出正号）。
    - 空格：对于有符号数，如果为正，使用空格填充符号位。（存在 `+` 时被忽略）
    - `#`：在某些情况执行“替代转换”，详见下文。
    - `0`：对于整数或浮点数，在前面填充前导 0 而不是空格。（存在 `-` 时被忽略）

- 可选，指定最小宽度。可以填写一个整数或者 `*` 字符。如果填写的是 `*` 字符，将会在这个参数之前额外接收一个 `int` 参数指定最小宽度。

- 可选，指定精度。可以填写 `.` 后跟一个整数或者 `*` 字符。精度的具体含义见下文。

- 长度修饰符、类型说明符。

以下是常见的类型说明符：
- `c`：以字符形式输出。接收一个 `int`。
- `s`：输出一个 C 风格字符串，接收一个 `char *`。精度指定最大字符数。
- `d`/`i`：输出十进制有符号整数。精度指定最小输出位数，不足则补充前导 0。通过精度指定的前导 0 会和数字看作一个整体，可以进一步通过其他设置进行其他填充。有以下长度修饰符：

| 修饰符 | 类型 |
|--|--|
| `hh` | `signed char`|
| `h` | `short` |
| 无 | `int` |
| `l` | `long` |
| `ll` | `long long` |

- `u`：输出十进制无符号整数。行为与 `d` 类似，输出对应的无符号版本（例如 `llu` 表示 `unsigned long long`）。

- `o`：输出八进制无符号整数。对于替代实现，输出一个额外的 `0` 前缀。

- `x`/`X`：输出十六进制无符号整数。对于替代实现，输出一个额外的 `0x` 前缀。所有字母的大小写和类型说明符相同。

- `f`：输出一个十进制浮点数，精度指定小数点后的位数。默认精度为 6。对于替代实现，即使小数点后没有数字也会输出小数点。`f` 或 `lf` 表示 `double`，`LF` 表示 `long double`。

- `p`：输出一个指针，具体行为由实现定义。

特别地，`%%` 转换说明符表示输出字面量 `%`。

`printf` 等可变参数的函数，在进行参数传递的时候会应用一定的参数提升原则。对于浮点数，`float` 会转化为 `double`。对于整数，应用整数提升，把 `bool`、`char` 和 `short` 等值域小于 `int` 的类型转换为 `int`。所以类似 `%f` 输出 `float`、`%c` 输出 `char` 等操作是安全的。

`int32_t` 这样固定宽度的整数类型，正确的转换说明符在头文件 `<cinttypes>` 中通过宏定义。

**如果 `printf` 的转换说明符和实际传入的类型不匹配，那么行为是未定义的**（例如用 `%lld` 输出 `int`）。

`printf` 返回 `int`，如果输出成功，表示输出的字符数量，否则返回一个负值。

**scanf：格式化输入**

`scanf` 可以提供一个格式字符串，根据指定的格式解析参数，并给传入的对应参数赋值。

具体的格式说明，见 [cppreference](https://en.cppreference.com/w/c/io/fscanf)。

大体上，格式字符串包含以下的部分：
- 除 `%` 以外的非空白字符：将会从输入中消耗一个完全相同的字符，如果下一个字符不相等，则导致函数失败。
- 任意空白字符：消耗零个、一个或多个连续空白字符（包含空格、`\n`、`\r` 等）。匹配过程是“贪婪”的，即会消耗尽可能多的字符。
- 转换说明符。具有以下格式：
    - 前导的 `%` 字符。
    - 可选，一个 `*` 字符。如果存在此选项，则仅会从输入中消耗字符，而不会赋值参数。
    - 可选，指定最大宽度。如果不提供宽度，可能导致一些情况下发生缓冲区溢出。
    - 长度修饰符、类型说明符。

常用的类型说明符包含以下几种：
- `c`：匹配一个字符。如果有提供宽度说明，则匹配恰好 `width` 个字符。输入为 `char *` 格式。
- `s`：匹配若干个非空字符。如果有提供，则仅会匹配至多 `width` 个字符。输入为 `char *` 格式，结尾追加一个空字符。
- `[set]`：匹配若干个连续字符，并且这些字符均属于字符集 `set`。如果 `set` 以 `^` 开头，表示集合为后续字符的子集。如果集合以 `]` 或者 `^]` 开头，则把 `]` 视作常规字符。如果有提供，则仅会匹配至多 `width` 个字符。
- 匹配一个整数。长度修饰符的含义与 `printf` 相同。

| 类型说明符 | 含义 |
|--|--|
| `d` | 有符号十进制整数 |
| `i` | 由前导字符决定，十进制/八进制（0）/十六进制（0x）整数 |
| `u` | 无符号十进制整数 |
| `o` | 无符号八进制整数 |
| `x` | 无符号十六进制整数 |

- `a`/`e`/`f`/`g`：匹配一个浮点数，支持十进制形式、十六进制形式、科学计数法、无穷大和 nan。`f` 表示 `float` 类型，`lf` 表示 `double` 类型，`Lf` 表示 `long double` 类型。
- `p`：匹配一个指针。格式由实现定义，但是与 `printf` 的输出格式相同。

除了 `[set]`、`c` 以外的转换说明符，都会消耗并丢弃所有的前缀空白字符。这使得可以通过 `scanf("%d%d", &a, &b)` 这样的格式输入两个空格分隔的整数。

**如果 `scanf` 的转换说明符和实际的指针类型不匹配，则行为未定义。**

`scanf` 返回一个整数，表示成功读入的参数数量。如果在读入第一个参数之前输入失败，返回 `EOF`。
