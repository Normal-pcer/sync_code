C++ 是许多信息学竞赛选手最熟悉的编程语言。日常训练中，我们可能只用到循环、数组这些基础功能，但这位朝夕相处的"老朋友"，其实藏着更多值得探索的奥秘。

也许你曾见过题解中神奇的语法"黑科技"，也许你被未定义行为导致的"玄学问题"困扰过，也许你面对突如其来的编译错误百思不得其解...

掌握这些知识，不会让你在赛场多拿几分，但能让你更加了解这个朝夕相处的代码伙伴。它们或许能帮你理解那些精妙的语言特性，或许能让你接触更现代的编程思维，又或许，只是满足你对技术世界的好奇心。

这个专栏并不是“语法大师课”，而是一次共同探索的旅程。我也只是一个 C++ 初学者，尝试分享自己理解中的一些点滴。

我们将从基础出发，逐步走进 C++ 的深处。虽然我的理解有限，无法覆盖那些艰深的内容。无论如何，都希望这些分享能为你打开一扇窗，了解一些可能平时了解不到的小知识，让你对这门语言多一分理解，这便是这篇专栏的最大意义。


# 前置知识
在正式开始之前，先来了解一些相关的概念。

## 编程工具
### 编译器

编译器是一种软件，负责将源代码编译成可执行文件。可执行文件（例如 Windows 系统的 exe 文件）可以被操作系统直接执行。

GCC（GNU Compiler Collection）是算法竞赛中最常用的 C++ 编译器。


代码编辑器负责帮助程序员编写代码。从定义上讲，记事本就可以算作编辑器。编辑器不负责代码的运行。

Sublime Text、Visual Studio Code 等都是常见的代码编辑器。

### 集成开发环境
集成开发环境（IDE）是一种集成了多种功能的工具，通常包含代码编写、编译运行、调试等功能。现代的代码编辑器，通过插件通常也能实现类似 IDE 的功能。

### 调试器
调试器可以帮助开发人员调试代码，通常包含断点（在程序运行到某处时停止运行）、逐行调试、查看变量值、检查运行时错误位置等功能。

gdb 是一个常用的调试器，并且**在 NOI Linux 的考试环境下可用**。

## C++ 标准
C++ 语言一直在发布新的标准，从 2011 年开始，每 3 年都会发布一个新标准。

当前的 C++ 标准有：C++98（C++03）、C++11、C++14、C++17、C++20、C++23，下一个标准是 C++26。

其中 C++03 只是在 C++98 的基础上做了简单的修订，并没有大幅度的更改。

本文讲述的内容，如果没有标注，默认是 C++98 就存在的。

## 编译器优化（O2 优化）
大多数的现代编译器都提供了优化选项。在代码不存在未定义行为的情况下，编译器优化选项可以保证程序行为正确，并且优化代码的运行速度。

常见的优化选项有 `-O0`（无优化）、`-O1`、`-O2`、`-O3`、`-Ofast` 等，优化效果通常是递增的。

很多情况下，一些简单的优化在开启优化选项 `-O2` 之后，都会被编译器自动完成（例如简单函数调用造成的开销，绝大多数情况下都会被内联）。

开启编译器优化后，可能让存在问题的代码行为变得奇怪，同时会影响调试器的使用。所以在调试时建议禁用优化。

**目前，在 CCF 组织的比赛中，均使用 C++14 标准，开启 O2 优化。**

# 基础语法
## 输入输出
```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello World!" << endl;
    return 0;
}
```
C++ 标准库中，主要有这几类输入输出方式：
- C 风格的输入输出：`scanf`，`printf`，`getchar`，`putchar`，`puts` 等。
- C++ iostream：`cin`，`cout` 等。
- C++23 print：`print`，`println` 等。

在这些标准库提供的工具中，我最常用的是 iostream。它较为简单，并且可以保证类型安全，无需考虑占位符和实际类型的配套问题。而 C++23 的 print 尚未受到广泛支持。

iostream 采用重载的右移（有时又称“流输入”）和左移（“流输出”）运算符进行输入输出。代码如下：
```cpp
int x;
std::cin >> x;  // 输入
std::cout << x;  // 输出
```

`cout` 可以通过输出一些操纵符，来进行一定程度的格式化输出。大多数操纵符在头文件 `iomanip` 中定义。例如，如下代码可以保留 2 位小数输出：
```cpp
std::cout << std::fixed << std::setprecision(2) << 3.1415;  // 3.14
```

执行以上代码以后，接下来所有的浮点数输出都会维持这样的格式。

iostream 最大的问题可能就是它在默认情况下效率很低。**可以通过以下代码来加速**：
```cpp
std::ios::sync_with_stdio(false);
std::cin.tie(nullptr);
```
这种方法通常叫做“关闭同步流”，可以大幅度提升 cin 和 cout 的速度。

第一行的原理是，默认情况下 C 风格的输入输出会维护一个缓冲区来加速（即内容不会立即输出到屏幕，而是存到缓冲区中，缓冲区满或者手动刷新再一次性输出）。而 iostream 为了和 C 兼容，会在每一次输入输出时都刷新缓冲区，导致额外开销。调用了 `ios::sync_with_stdio(false)` 之后就不会每次刷新了。

第二行的原理是，默认情况下 cin 会和 cout 互相绑定，在每次使用 cin 输入时都刷新 cout 的缓冲区。这样可以避免交替使用输入输出时的额外刷新开销。

由于 `endl` 会刷新缓冲区，使用 `'\n'` 而不是 `endl` 换行也会加速输出。

经过这样优化的 `cin` 和 `cout`，速度会略快于 `scanf` 和 `printf`。

**关闭同步流的情况下，iostream 和 C 风格输入输出不能混用**。否则可能会导致多次输出的结果乱序。

有些时候，一些题目会要求输入不定量的信息。这种输入之所以可行，是因为从控制台输入信息，本质上是从一个虚拟的文件 `stdin` 输入。文件是有边界的，读到文件结尾就会获得 EOF 信息（End Of File），无法继续读入。

`cin` 可以通过 `cin.good()`（返回 `true`/`false`）来判断是否处于正常状态。同时 `cin.eof()` 可以判断是否到达文件末尾，`cin.fail()` 和 `cin.bad()` 可以判断是否出现其他的问题，例如读入的整数超过类型上限，或者期望读入整数实际读到字母，将会使得 `cin.fail()` 返回 `true`。

如果 `cin.good()` 返回 `false`，此时将会拒绝接下来的读取操作（变量将会保持原值不被修改）。

在条件判断中，`cin` 对象可以隐式转换为布尔值，即 `cin.good()`。可以通过以下代码来持续读入整数直到文件末尾。在控制台中运行时，可以按下快捷键 Ctrl+Z（Windows）或者 Ctrl+D（Linux）并换行，来手动输入一个 EOF。

```cpp
int x;
while (cin >> x) {  // cin/cout 输入输出之后返回自己
    cout << x << ' ';
}
```

## 未定义行为
接下来的代码中，将会涉及到“未定义行为”及相关概念。可以参考 [cppreference](https://en.cppreference.com/w/cpp/language/ub.html) 页面。

C++ 的代码可能出现以下的错误类别：
- **非良构**（ill-formed）。程序存在语法错误，或者可以诊断的语义错误。标准要求编译器对这种行为给出诊断信息，通常会导致编译错误。
- 非良构，但是不要求诊断（no diagnostic required）。有些情况下，程序存在语义错误，但是错误可能在链接时才能发现，或者进行诊断需要的代价过大。这类程序被执行，行为是未定义的。
- **实现定义行为**（implementation-defined behavior）。程序在不同的实现中（包括编译器、标准库实现、运行时环境等），可能会有不同的行为。但是符合标准的实现需要在文档中说明每种行为的实际效果。
    - 例如，`long` 类型的大小是实现定义的。在常见的实现中，有些是 4 字节，有些是 8 字节。
- **未指定行为**（unspecified behavior）。程序行为在不同的实现中有所不同，并且实现不需要说明这些行为的效果。
    - 例如，一些情况下的求值顺序，相同的字符串字面量是否指向不同地址。
    - 不应该依赖未指定行为。
- **未定义行为**（undefined behavior，简称 ub）。程序的行为将不受任何限制。
    - 例如，数组的越界访问，有符号整数溢出，空指针解引用。
    - 实现无需对未定义行为进行诊断（因为有些只能在运行时被发现）。
    - **未定义行为可能导致任何问题**，编译器也可以基于“程序不存在未定义行为”的假设进行优化。
    - 通常情况下，代码开启编译器优化前后行为不一致，就是由于存在未定义行为。

以下是几个编译器可能优化的例子：
```cpp
bool f(int x) {
    return x + 1 > x;  // 不溢出的情况下，整数 +1 一定大于自身
}
// 可能优化成：
bool f_(int x) {
    return true;
}
```

```cpp
int g(int *ptr) {
    int value = *ptr;  // 已经进行解引用，基于 UB 假设一定不是空指针
    if (ptr == nullptr) {
        return 0;
    } else {
        return value;
    }
}
// 可能优化成：
int g_(int *ptr) {
    return *ptr;
}
```

## 变量
```cpp
#include <iostream>
using namespace std;

int main() {
    int a, b;
    cin >> a >> b;
    cout << a + b << '\n';
    return 0;
}
```

C++ 的“变量”（Variable）是通过标识符引用的对象（Object），指向一个内存中的存储单元，持有的值可以改变。变量几乎是一切数值计算的基础。这个最简单的“两数和问题”中，我们就使用了变量进行计算。

### 变量名
变量名必须是一个合法的“标识符”（[Identifier](https://en.cppreference.com/w/cpp/language/identifiers.html)）。即有以下的要求：

- 首字符必须为英文字母 `A-Za-z` 或下划线 `_`，或其他具有 XID_Start 属性的 Unicode 字符。
- 其余字符必须为英文字母 `A-Za-z` 、数字 `0-9`或下划线 `_`，或其他具有 XID_Continue 属性的 Unicode 字符。

值得注意的是，自 C++11 起，绝大多数语言中的字母（例如中文汉字），甚至表情符号，都是合法的标识符（即上文提到的 Unicode 字符）。

除此以外，用户定义的标识符（变量、函数、类型等）不能与[关键字](https://en.cppreference.com/w/cpp/keyword.html)完全相同。以双下划线开头（如 `__reserved`），或者单下划线紧跟大写字母开头（如 `_Reserved`），行为是未定义的。

### 变量作用域
变量的作用域主要分为局部作用域和命名空间作用域等。

在函数等花括号（`{}`）包裹的代码块中定义的变量，具有局部作用域。局部作用域的变量，自声明后开始可见，直到代码块结束。

在命名空间中声明的变量，具有命名空间作用域。这类变量自声明后开始，在命名空间内始终可见，或者通过命名空间名来访问（`ns::name`）。全局作用域可以看作一个特殊的命名空间作用域，它自声明后开始，在全局内始终可见。

不同作用域的同名变量存在“遮蔽”原则，内层作用域的同名变量会隐藏外层作用域的变量。

```cpp
#include <iostream>
int x = 0; // 全局变量
int main() {
    std::cout << x << '\n'; // 输出 0
    int x = 1; // 局部变量将会遮蔽全局的 x
    std::cout << x << '\n'; // 输出 1
    std::cout << ::x << '\n'; // 可以通过 ::x 强制指定全局作用域的 x，输出 0
    return 0;
}
```

可以根据以上代码理解这些原则。

类型、函数等的作用域规则，也和变量相同。

### 存储期
存储期（Storage duration）指定了一个对象的生命周期，即在何时被销毁并回收资源。变量的存储期由定义的方式决定。

C++ 有以下的几种存储期：
- 自动存储期。这是局部变量的默认存储期，会在离开自己的作用域后自动销毁。
- 静态存储期。这是命名空间作用域（包括全局作用域）变量的默认存储期，在程序结束后销毁。
- 动态存储期。通过 `new`、`malloc` 等方式在堆空间动态分配对象的属于动态存储期，需要通过配对的解分配函数来销毁。
- 线程存储期。对于多线程程序，这类对象对每一个线程都会有一个独立的值，生命周期与这个线程相同。

有对应的说明符可以指定存储期。
- `auto`：**C++11 起含义改变**。此前表示自动存储期。
- `register`：**在 C++17 起被移除**。此前用于请求编译器把这个值存储在寄存器中，这个请求可以被忽略。
- `static`：静态存储期。
- `thread_local`：线程存储期。
- `extern`：用于声明一个变量（而不是定义），链接到一个外部的来源。

`mutable` 关键字在 cppreference 中被归类为存储说明符，但是实际不会影响存储期，所以不在此讲述。

尽管 `register` 关键字直到 C++17 才被移除，但是即使在更早的标准中，编译器通常也会忽略它。不要试图使用这个关键字优化性能，这不会有任何作用。

自动存储期的对象将会存储在“栈空间”中，栈空间的容量有限（通常为 8MB），所以定义一些较大的数组，或者递归层数过深，都可能会出现“爆栈”的问题。但是大部分 OJ 和比赛环境，以及 CCF 组织的比赛中，允许程序使用无限的栈空间（即与程序总体内存限制相等），这些情况下可以放心使用局部数组和递归（局部数组需要手动初始化）。

如果想要设置无限栈空间，可以通过如下方式：
- 对于 Windows 系统，编译选项（GCC 为例）添加 `-Wl,-stack=2147483647`。
- 对于 Linux 系统，运行程序前在终端执行 `ulimit -s unlimited`。

全局或命名空间作用域的静态变量，将会在调用主函数之前进行初始化。

可以在局部作用域中通过 `static` 关键字来定义一个静态变量，这个变量将仅会在第一次运行到定义处的时候进行一次初始化，接下来每次使用都会保有一个相同的值。可以结合以下代码理解。


```cpp
#include <iostream>

void f() {
    static int count = 0;
    count++;
    std::cout << count << ' ';
    // 静态变量的值不会被清除
}

int main() {
    f(); f(); f(); // 输出 1 2 3
    return 0;
}
```

### 变量初始化
定义一个变量的同时会进行初始化，赋予其一个初始值。C++ 的变量初始化规则十分复杂，接下来我们将会进行一些简单的讲解。

本章节中可能会涉及到一些后续章节才出现的知识。如果出现了你不理解的内容，可以暂时忽略。

在章节的结尾，将会有一段简要的总结。你也可以通过这段总结来理解。

#### 零初始化
零初始化（[Zero-Initialization](https://en.cppreference.com/w/cpp/language/zero_initialization.html)）是将对象逐位赋值为 0 的初始化方式。C++ 中没有专用的零初始化语法，但是其他初始化方式可能包含零初始化。

**所有具有静态存储期的变量**，将会在进行其他初始化之前，先进行一次零初始化。平时常见的结论“全局变量会自动赋值为 0”就是来自这条规则。

#### 默认初始化
默认初始化（[Default-Initialization](https://en.cppreference.com/w/cpp/language/default_initialization.html)）是在没有指定初始化器时的初始化方式。例如以下场景将会执行默认初始化：
```cpp
int x;
auto *ptr = new double;
```

另外，在类的构造函数中，没有在初始化列表中提及的成员，也会执行默认初始化。

```cpp
struct A {
    int data;
    A() {}
};
A p;  // p.data 将会执行默认初始化
```

对类型 `T` 进行默认初始化的效果如下：
- 如果 `T` 是类类型（Class Type，由 `class`、`struct` 或 `union` 关键字定义的类型），则调用默认构造函数（空参数列表），为对象提供初始值。
- 如果 `T` 是数组类型，对数组的每个元素进行默认初始化。
- 否则，**不额外执行初始化**。

**对象在未执行初始化的情况下，将会持有一个不确定的值**，直到这个值被替换。使用这个不确定的值进行任何求值操作，都是未定义行为。

但是由于静态存储期的对象会预先进行一次零初始化，所以这种写法对它们是安全的。

C++26 起规定，对于一个自动存储期的变量，并且没有被标识 `[[indeterminate]]`，将会有以下行为：
- 构成该对象存储的所有字节，填充一个错误值。这个错误值由实现定义，但是与程序状态无关。
- 如果使用错误值进行求值操作，则行为是错误行为（Erroneous Behavior）。错误行为仍然应该被视作不正确的结果，但是标准建议实现对错误行为进行诊断，而非像未定义行为一样假设不会存在并促进优化。

C++26 引入的错误填充值，往往会导致未初始化的对象拥有一个异常值（例如无效指针，或者绝对值很大的整数和浮点数），避免由于“不确定值”有时恰好符合期望，而产生偶发性的错误。

`const` 对象不允许默认初始化。

#### 值初始化
值初始化（[Value-Initialization](https://en.cppreference.com/w/cpp/language/value_initialization.html)）在使用空初始化器构造对象时执行，以下是几种常见的场景：

```cpp
int x{};
auto *ptr = new double();
std::cout << float() /*构造临时对象*/ << '\n';
char arr[100]{};
```

下文中用 `T` 代指对象类型。

有以下特例：
- 如果 `T` 是聚合类型（见下文“聚合初始化”），那么执行聚合初始化。但是这种情况下聚合初始化的行为与值初始化的效果是一致的。
- 如果 `T` 没有默认构造函数，但是有一个接收 `std::initializer_list` 的构造函数，那么执行列表初始化。

值初始化的效果如下：
- 如果 `T` 是类类型，那么：
    - 如果它的默认构造函数不是用户提供的（即自动生成），先执行零初始化。
    - 接下来，执行默认初始化。
- 否则，如果 `T` 是数组类型，值初始化每个元素。
- 否则，对象将会被零初始化。

值初始化在大多数情况下可以保证所有元素被正确初始化（一个反例为上文“默认初始化”章节的 `p.data`）。

#### 聚合初始化
聚合初始化（[Aggregate-Initialization](https://en.cppreference.com/w/cpp/language/aggregate_initialization.html)）是通过初始化列表来初始化聚合类型的过程。这是一种特殊的列表初始化。

##### 聚合类型
聚合类型（Aggregate）是以下类型之一：
- 数组类型
- 符合以下要求的类类型
    - 没有用户声明或继承的构造函数。（C++20 起，此前的要求类似，但是略有不同）
    - 没有私有（private）或受保护（protected）的非静态数据成员。
    - 没有虚基类（virtual），没有私有或受保护的基类。（C++17 起，此前要求没有任何基类）
    - 没有虚成员函数。
    - C++11 及以前的版本，还要求没有默认成员初始化器（Default Member Initializers，即在声明成员的同时赋默认值）。

##### 指派初始化器
C++20 引入了指派初始化器（Designated Initializers），可以通过成员名称和目标值之间的键值对来进行聚合初始化。

```cpp
struct A { int a; double b; };
A a{.a = 5, .b = 9.0};  // 指派初始化器
```

##### 窄化转换
窄化转换是有潜在精度丢失的转换方式。目标类型不能存储源类型的所有值时，视为窄化转换（例如 `double` 到 `int`，`long long` 到 `int`）。

在标准禁止窄化转换的操作中，部分编译器可能实现为仅视为警告，不拒绝编译。

##### 初始化流程
聚合初始化可以分为显式初始化（explicit）和隐式初始化（implicit）。

首先，确定需要显式初始化的元素：
- 如果初始化列表是指派初始化器，则包含对应的所有成员。
- 否则，按照声明顺序包含最靠前的若干个元素。如果一个成员 `x` 也是聚合体，并且实际传入的值不是聚合体，将会进一步匹配 `x` 的全体成员，再对 `x` 进行聚合初始化，减少一层花括号嵌套。

```cpp
struct A { int x = 0, y = 0, z = 0; };
A arr[2] {0, 1, 2, 3, 4, 5};  // 相当于 {{0, 1, 2}, {3, 4, 5}}
```

如果 `T` 为联合体（union），包含超过一个显式初始化的元素，程序非良构；若是使用指派初始化器，则只能指定一个成员。

接下来，按照声明顺序初始化这些选中的元素。初始化每个成员时相当于使用复制初始化。

接下来，如果 `T` 不是联合体，每个未显式初始化的成员按照以下方式隐式初始化：
- 如果这个元素有默认成员初始化器，从初始化器初始化它。
- 否则，如果元素不是引用，从空的初始化列表对它进行拷贝初始化（多数情况下等价于值初始化）。
- 否则，程序非良构。

特别地，通过字符串字面量初始化一个字符数组，也属于聚合初始化。允许的字符类型有：`char`（或 `signed` 和 `unsigned` 变种）、`wchar_t`、`char16_t`（C++11 起）、`char32_t`（C++11 起）和 `char8_t`（C++20 起）。数组过长的部分将用 0 填充。

聚合初始化的过程中，不允许对参数进行窄化转换。

```cpp
char s[30]{"This is a C-style string."};
```

#### 列表初始化
通过花括号包裹的初始化列表初始化对象的方式，叫做列表初始化（[List-Initialization](https://en.cppreference.com/w/cpp/language/list_initialization.html)）。

```cpp
std::pair<int, int> p = {1, 2};
std::vector<int> v{0, 1, 2, 3};
```

类似以上方式的初始化，属于列表初始化。

上下两种方式，以语义上是否需要紧跟一次复制为分别，又称为“复制列表初始化”和“直接列表初始化”。例如，向函数参数传递一个初始化列表，或者将初始化列表作为返回值，都属于“复制列表初始化”。经过编译器优化，这种方式通常不会有额外的复制开销，

复制列表初始化，不会调用标记为 `explicit` 的构造函数。

列表初始化有以下的流程：
- 如果初始化列表是指派初始化器，执行聚合初始化。
- 如果 `T` 为聚合类型，并且初始化列表提供了一个同类型的对象，则从这个对象初始化。（依据自身类别进行复制初始化/直接初始化）
- 如果 `T` 为字符数组，且用花括号括起来一个对应的字符串字面量，则由这个字符串进行聚合初始化。
- 如果 `T` 为聚合类型，执行聚合初始化。
- 如果初始化列表为空，且 `T` 为存在默认构造函数的类类型，执行值初始化。
- 如果 `T` 为 `std::initializer_list` 的特化，逐个成员复制初始化。
- 如果 `T` 为类类型，考虑其构造函数：
    - 接受单个 `std::initializer_list` 参数的构造函数，优先调用。
    - 对于初始化列表中指定的参数执行重载决议，寻找最佳匹配的构造函数。
- 否则（`T` 不是类类型），并且初始化列表中只有一项，并且 `T` 不是引用，或者 `T` 是兼容的引用（同类型或是其基类），则从这个对象初始化，但是不允许窄化转换。
- 否则，如果 `T` 是不兼容的引用类型，将会通过复制列表初始化创建一个 `T` 所引用类型的临时量，然后引用绑定到这个临时对象。如果 `T` 是非 `const` 的左值引用，那么操作失败。
- 否则，如果初始化列表为空，执行值初始化。

初始化列表中，求值顺序是固定的从前到后。相对地，**函数调用的参数求值顺序是不固定的**。

##### std::initializer_list
`std::initializer_list` 可以存储若干个类型相同的对象。列表初始化中，将会优先使用接受 `std::initializer_list` 的构造函数。

例如，通过花括号初始化存在若干个初始元素的 `std::vector`，就是通过 `std::initializer_list`。
```cpp
std::vector<int> vec{0, 1, 2, 3, 4};
```

#### 复制初始化
复制初始化（[Copy-Initialization](https://en.cppreference.com/w/cpp/language/copy_initialization.html)）指从另一个对象初始化一个对象，在语义上应该发生复制。

```cpp
int x = y;
f(x);  // 函数调用时也是复制初始化
```

- 如果初始化器的类型为 `T`，调用 `T` 的构造函数。
- 初始化器类型与 `T` 无关，则尝试调用：
    - 初始化器类型的转换函数，转换为 `T` 或派生类。
    - `T` 的构造函数，接受初始化器类型。
- 尝试应用标准转换。

复制初始化中，不会使用任何标记为 `explicit` 的构造函数。有些情况下的复制往往可以被编译器优化掉，转换成直接在目标位置构造对象。

C++17 起，标准强制要求进行复制消除，即初始化器为函数返回值这样的纯右值时，一定不会进行额外的复制。此前的编译器往往也会做这样的优化。

#### 直接初始化
直接初始化（[Direct-Initialization](https://en.cppreference.com/w/cpp/language/direct_initialization.html)）通过指定的参数调用构造函数，初始化对象。

```cpp
std::vector<int> vec(/*n:*/10, /*default:*/2);
```

直接初始化的效果如下：
- 如果 `T` 是数组类型：
    - C++20 起，数组按照聚合初始化的方式进行初始化，但允许进行窄化转换，并且任何没有初始化器的元素将进行值初始化。
- 如果 `T` 是类类型：
    - C++17 起，标准规定实现类似复制初始化的“复制省略”机制，如果参数是 `T` 的纯右值，直接使用初始化器本身初始化目标对象。
    - 检查 `T` 的构造函数，通过重载决议决定最佳匹配项。
    - C++20 起，如果 `T` 是聚合类型，使用类似聚合初始化的方式进行初始化。但是存在以下区别：允许窄化转换，不存在花括号省略机制，没有初始化器的元素将会执行值初始化。
- 否则（`T` 不是类类型），源类型是一个类类型，则会检查其转换函数。
- 否则，如果 `T` 为 `bool` 且源类型为 `std::nullptr_t`，初始化对象为 `false`。
- 尝试应用标准转换。

以下的写法是错误的，因为会和函数声明混淆。这通常可以使用空的花括号代替。
```cpp
std::vector vec(/*参数列表为空*/);
```

#### 总结
核心规则可以大致概括为：
- 零初始化：逐位赋值为 0，全局/静态变量自动执行。
- 默认初始化 `int x`：
    - 类类型，调用默认构造函数。
    - 基本类型，**局部变量的值不确定**，全局/静态变量预先零初始化为 0。
- 值初始化 `int x{}`：
    - 基本类型，初始化为 0。
    - 类类型，调用默认构造。
    - 通常是最安全的初始化方式。
- 直接初始化 `int x(5)`：
    - 直接调用匹配的构造函数。
- 复制初始化 `int x = 5`：
    - 实际行为通常与直接初始化一致。
    - 禁用 `explicit` 构造函数。
    - 经过编译器优化，通常不会有额外的复制。
- 列表初始化 `int x{5}`：
    - 优先匹配接受 `std::initializer_list` 的构造函数。
    - 禁止窄化转换。

### cv 限定符（常量性、易变性）
类型可以通过 `const` 和 `volatile` 修饰，获得常量性或者易变性。修饰符不会影响对象的底层表示、对齐要求等。

数组类型与它的元素拥有相同的 cv 限定符。

对象具有的 cv 限定符，也会给予它的成员。被声明为 `mutable` 的成员除外，它不会继承对象的常量性。

#### 常量性
具有常量性的对象不能被修改。直接修改会导致编译错误，而间接修改（例如通过 `const_cast` 获得非常量指针，或者直接修改底层内存）**会导致未定义行为**。

#### 易变性
具有易变性的对象，每次读写都要求立即和内存同步，禁止编译器进行缓存、指令重排等优化。在涉及到信号处理、系统中断、直接操作内存等情况下需要用到。编译器会假设代码始终单线程执行，从而在一些情况下，可能导致意料之外的优化。

## 类型
### 基本类型
C++ 包含以下的[基本类型](https://en.cppreference.com/w/cpp/language/types.html)：
- 整数类型
- 浮点数类型
- `std::nullptr_t` 空指针类型
- `void` 空类型

#### 整数类型

有以下对于整数类型的长度修饰符。长度修饰符的效果由实现定义，但是需要满足一定要求。

| 长度修饰符 | 要求 |
|--|--|
| short | 不小于 16 位 |
| (无) | 不小于 16 位 |
| long | 不小于 32 位 |
| long long | 不小于 64 位 |

完整的整数类型包含以下部分：

| 组成部分 | 描述 |
|--|--|
| 长度修饰符 | 指定数字位数要求 |
| 符号标识符 | 指定数字有符号（`signed`）/无符号（`unsigned`），不填为有符号 |
| `int` | 如有其他的单词描述，可以省略 |

这几个部分的顺序可以交换，`signed short int`、`long long unsigned int`、`long int signed` 都是合法的。

除了以上的标准整数类型，还有以下的整数类型：
- 布尔类型 `bool`。
- 字符类型。
    - `signed char`，`unsigned char`。
    - `char`。以上三个类型的长度相同，但是始终是三个不同类型。`char` 是否有符号由实现定义。
    - `wchar_t`，`char16_t`（C++11 起），`char32_t`（C++11 起），`char8_t`（C++20 起）。
- 扩展整数类型。
    - GCC 扩展的 `__int128` 就是扩展整数类型。

此外，标准保证 `sizeof(char)` 为 1，且 `sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)`。`sizeof` 返回值的单位为字节，字节的位数由实现定义，但是绝大多数情况下都是 8 位。

#### 浮点数类型
- `float`。单精度浮点数，通常为 IEEE-754 binary32 格式。
- `double`。双精度浮点数，通常为 IEEE-754 binary64 格式。
- `long double`。扩展精度浮点数。
- 由实现定义的扩展浮点数类型。

浮点数不一定映射到 IEEE-754 规定类型。它的精度和占用空间都是实现定义的。大多数实现下，`float` 和 `double` 都是遵循 IEEE-754 的规定，而 `long double` 的实现则更加多样。

### 类型转换
C++ 的类型转换分为隐式（implicit）和显式（explicit）的。

#### 隐式类型转换
当一个类型在上下文中不适用，但是可以转化为一种合适的类型时，就会发生隐式类型转换。

例如希望给一个 `bool` 类型的变量赋值，但是传入了一个 `int`，就会出现一次隐式转换（0 变为 `false`，非 0 值变为 `true`）。

隐式类型转换可以由以下的步骤组成：

- 零个或一个标准转换序列。
- 零个或一个用户定义的转换。
- 如果使用了用户定义的转换，还可以接受零个或一个标准转换序列。

传递给构造函数的参数，或者在两个非类类型之间转换，只允许标准转换。

一个标准转换序列，包括以下组成部分：
- 从以下集合中选择零个或一个转换：
    - 左值到右值转换。
    - 数组到指针转换。
    - 函数到指针转换。
- 零次或一次数值提升或数值转换。
- 零次或一次函数指针转换。
- 零次或一次限定符转换。

用户定义的转换，包含接受单个参数的构造函数，或者转换函数。但是二者都不能标记为 `explicit`。例如以下代码可以支持 `int` 到 `A`、`A` 到 `bool` 的隐式类型转换。

```cpp
struct A {
    int value{};
    A() {}
    A(int x): value(x) {}

    operator bool() const noexcept {
        return value != 0;
    }
};

A a = 5;
bool flag = a;
```

##### 值类别
在上文中提到了左值和右值的概念，我们在此处先简单地介绍一下。

C++ 的表达式分为纯右值（prvalue）、将亡值（xvalue）和左值（lvalue）这三大类。这里只介绍纯右值和左值。

左值和右值，这个名称最初的意味是“左值可以出现在赋值运算符的左侧”。尽管现在不是这样，在某些情况下，左值有可能无法赋值，右值有可能允许赋值。

左值用于确定一个已经被存储的特定对象或者函数。例如变量 `a`，数组访问 `arr[0]` 都是左值。

纯右值是没有持久存储的临时值，例如：
- 字面量，如 `1`，`3.4`，`'c'`。（字符串字面量除外）
- 算术表达式结果，如 `a + b`。
- 函数调用结果（不返回引用），如 `std::sqrt(4)`。

##### 实例
例如以下代码：
```cpp
#include <iostream>
#include <string>

int main() {
    struct A {
        int value{};
        A() {}
        A(int value): value(value) {}

        operator int () const {
            return value + 1;
        }
    };

    A a{5};
    bool flag = a;
}
```

以上代码 `bool flag = a` 一句，通过以下途径转换：
- 一个标准转换序列。包含左值到右值的转换。
- 一个用户定义的转换。调用转换函数 `operator int`。
- 一个标准转换序列。包含 `int` 到 `bool` 的数值转换。 

##### 上下文相关转换
一些语境下期望的类型为 `bool`，此时进行隐式类型转换，效果相当于显式类型转换 `static_cast<bool>(x)`。

- `if`、`while`、`for` 的条件表达式。
- **内置运算符** `!`、`&&`、`||` 的操作数。
- 条件运算符 `?:` 的第一个操作数。
- `static_assert`、`noexcept`、`explicit` 的条件表达式。

#### 显式类型转换
C++ 中的显式类型转换，通过以下几类关键字进行。将 `x` 转换为 `T` 类型的方法是 `static_cast<T>(x)`（或使用其他关键字）。
- [static_cast](https://en.cppreference.com/w/cpp/language/static_cast.html)，适用于一些较为安全的转换，例如：
    - 基础类型间的数值转换。
    - 基类、派生类指针之间互相转化。
    - 将 `void *` 转化为具体类型指针。
    - `static_cast<void>` 用来丢弃一个值。
    - 调用构造函数、转换函数。（允许使用 `explicit`）
- [reinterpret_cast](https://en.cppreference.com/w/cpp/language/reinterpret_cast.html)，根据底层内存重新解释对象，例如：
    - 指针和整数互相转换。
    - 无关类型的指针之间互相转化（不能移除 `const`/`volatile`）。
- [const_cast](https://en.cppreference.com/w/cpp/language/const_cast.html)，适用范围：
    - 对于带有 `const`/`volatile` 修饰类型的指针，可以移除修饰符。
- [dynamic_cast](https://en.cppreference.com/w/cpp/language/dynamic_cast.html)，适用于多态类型带有运行时检查的转换。此处不做提及。

滥用 `reinterpret_cast` 和 `const_cast` 极易引起未定义行为。原对象为 `const` 时，通过 `const_cast` 去除 const 修饰符之后再修改，**仍然属于未定义行为**。它通常只能用于和接受非常量指针的函数交互，并且可以保证不会真的修改传入内容。

`reinterpret_cast` 可以获得任意类型的指针，但是对这个指针进行解引用，必须保证**目标类型有合适的可访问性**，否则**仍然属于未定义行为**。`T` 只能通过以下的类型被访问：
- `T` 本身。
- 如果 `T` 为整数类型，`T` 对应的有符号/无符号版本。
- `char`、`unsigned char`、`std::byte`。这允许通过字符数组来观察对象在内存中的表示。

例如：

```cpp
double x = 5;
using u64 = std::uint64_t;

u64 x1 = *reinterpret_cast<u64 *>(&x);  // UB
u64 x2; std::memcpy(&x2, &x, sizeof(u64));  // memcpy 逐字节复制是安全的
u64 x3 = std::bit_cast<u64>(x);  // std::bit_cast 是 C++20 引入的安全转换方式

union { u64 int_; double double_; } tmp;
tmp.double_ = x; u64 x4 = tmp.int_; // UB；union 不可以访问错误成员
```

使用括号包裹一个类型名，随后接一个表达式，叫做 C 风格类型转换。C 风格转换支持上述所有的转换方式。现在 C++ 中，出于安全性考虑，**不推荐使用这种类型转换**。例如 `(int)3.0`、`(double)(a + b)`。

一些类型后可以接一个括号，传入参数进行类型转换。这种转换方式本质上是对象的直接初始化，但有时会被称为“函数式转换”。例如 `char(32)`，`std::string("test")`。

### 类型别名
C++ 中，可以为类型声明别名，用于简化代码。类型别名和原类型在各种方面都是完全相同的，不会创建新的类型。

#### `using` 类型别名
C++11 引入了 `using` 关键字作为声明类型别名的含义，这也是现在 C++ 推荐的声明方式。用法如下：
```cpp
using i64 = long long;
```

这个语句为 `long long` 声明了一个类型别名 `i64`。

类型别名也适用和变量相同的作用域规则。

`using` 声明别名最大的特点是它可以支持模板。

#### `typedef` 类型别名
`typedef` 声明类型别名的方式与变量相似，源类型在前，别名在后。
```cpp
typedef long long i64;
```

### 字面量类型
C++ 中，所有字面量的类型都是确定的。

#### 整数字面量
通常情况下，一个整数类型字面量的类型通过如下简化规则确定（完整表格见 [cppreference](https://en.cppreference.com/w/cpp/language/integer_literal.html)）。

- 默认情况下为 `int`。如果数字过大，超过 `int` 存储范围，向上依次尝试 `long` 和 `long long` 类型。
- 如果使用了 `U` 后缀，则选定数字的无符号版本。
- 如果使用了 `L` 后缀，则从 `long` 开始尝试。如果使用了 `LL` 后缀，则从 `long long` 开始尝试。

`U` 后缀可以和其他的后缀组成 `UL` 或者 `ULL`。后缀大小写不敏感，但是 `LL` 的两个字母形式必须相同。

特别地，二进制、八进制或者十六进制表达，即使没有指定 `U`，也会尝试选定无符号类型。

例如以下的整数字面量（假设 `int` 和 `long` 为 32 位，`long long` 为 64 位）：
```cpp
5; // 默认为 int
2'147'483'648; // 超过 int 和 long 最大值，为 long long
100LL; // 手动指定为 long long
24llU; // 与大小写、顺序无关，为 unsigned long long
0x80000000;  // unsigned int
```

#### 浮点数字面量
浮点数字面量的类型由后缀决定。

- 无后缀，表示 `double`。
- `f` 后缀，表示 `float`。
- `l` 后缀，表示 `long double`。

同样对大小写不敏感。

### 字符串字面量
字符串字面量的类型是对应的常量字符数组。例如 `"Hello"` 的类型是 `const char[6]`（包含结尾的空字符）。

#### 原始字符串
C++11 引入了原始字符串语法。类似 `R"$(content)$"` 的形式为一个原始字符串，其实际值和 content 相同，并且无视转义字符，可以换行。其中的美元符号可以换为任意字符串（也可以为空），它不会出现在真正的内容中。例如：
```cpp
std::cout << R"raw-str(\\\\ ()() """"
\n\n\n\n)raw-str";
```

得到如下输出：
```
\\\\ ()() """"
\n\n\n\n
```

原始字符串的行为和普通的字符串相同。


### 自动类型推导
#### `auto`
C++11 起，[auto](https://en.cppreference.com/w/cpp/language/auto.html) 关键字用作自动类型推导。

变量初始化时，可以使用 `auto` 来代替实际类型。推导类型时有以下规则：
- 忽略初始化表达式的引用性。
- 如果类型说明符不带引用，忽略初始化表达式的 cv 限定符。
- 如果类型说明符是 `auto &&`，根据初始化表达式的类别，推导为左值引用或右值引用（见相关章节）。

例如以下代码：
```cpp
const int x = 10;
auto x1 = x; // x1 的类型为 int，不带 const
volatile auto x2 = x; // x2 的类型为 volatile int，也不带 const
auto &x3 = x; // x3 的类型为 const int &，引用类型保留 const
auto x4{x}; // 各种初始化方式都可以使用 auto
```

C++20 起，`auto` 也可以用于函数参数类型。例如以下代码：
```cpp
auto add(auto a, auto b) { return a + b; }
// 等价于
template <typename Ta, typename Tb>  // 详见模板章节
auto add_(Ta a, Tb b) { return a + b; }
```
lambda 函数自 C++14 起就有类似特性。

#### `decltype`
C++11 起，可以用 `decltype` 推断表达式的类型。

如果参数是一个实体（Entity，如没有括号包裹的变量名、函数名、成员访问表达式），`decltype(entity)` 返回它的类型。

否则，如果参数是类型为 `T` 的其他表达式，基于其值类别：
- `prvalue`，产生 `T` 类型。
- `lvalue`，产生 `T &` 类型。
- `xvalue`，产生 `T &&` 类型。

被 `decltype` 包裹的表达式不会被真正执行。

例如：
```cpp
int x;  // 未初始化
using T1 = decltype(x);  // int
using T2 = decltype((x));  // 此时为表达式，int &
using T3 = decltype(x + 1.0);  // double
// 没有真正使用 x 的值，所以不是 UB。
```

## 数值计算
算术运算等数值计算，算是最常用的操作了。接下来，我将会介绍一些和数值计算相关，可能被忽视的小细节。

### 类型转换
在进行数值计算之前，需要把两个操作数转换为相同类型。

对于整数运算，将会从下表中选定第一个可以同时表示两个操作数的类型，将二者同时转换为这一类型。

- `int`
- `unsigned int`
- `long`
- `unsigned long`
- `long long`
- `unsigned long long`

算术运算的结果类型，和这个转换后的类型相同。例如：
- `int + long long` -> `long long`
- `char + char` -> `int`

关于浮点数的运算具有相似的规则，将会把整数转换为浮点数、浮点数转换为精度较高的。例如：
- `int + float` -> `float`
- `float + double` -> `double`

一个常见的错误是，STL 容器的 `.size()` 方法返回 `std::size_t`，通常为 64 位无符号整数。于是会出现这样的问题：
```cpp
for (int i = 0; i < v.size() - 1; i++) {
    // 如果 v.size() = 0，相减之后得到的其实是 2^64 - 1
    // 导致循环无法结束
}
```

另一个常见的错误，左移运算符的返回值仍然满足这个规律。所以 `1 << 33` 这样的代码会导致未定义行为。可以写作 `1LL << 33`。

### 数值溢出
所有的数据类型（如整数 `int`，浮点数 `double`）都会有自己的取值范围。当运算结果超过这个范围的时候，就会出现“溢出”，导致意料之外的结果。

不同类型的溢出行为也有所不同。
- 有符号整数：**未定义行为（UB）**。
- 无符号整数：自然溢出。（例如 32 位无符号整数，相当于结果对 $2^{32}$ 取模）
- 浮点数：实现定义，可能是产生 `inf` 等 IEEE-754 特殊值。

另外，数值转换的过程中，如果原值不能被目标类型储存，会有以下行为：
- 目标为有符号整数：实现定义，并在 C++20 起良好定义。（对 $2^N$ 取模）
- 目标为无符号整数：始终良好定义。（对 $2^N$ 取模）
- 目标为浮点数：相关精度问题由实现定义。

### 求值顺序
C++ 中，很多求值顺序都是未指定或无序的（为了描述简单，我们暂时不辨析这两个概念）。例如 `f() + g()`，标准允许先调用 `f()` 再调用 `g()`，也允许与其相反的顺序。

简单地讲，一个表达式最好需要满足以下规则，否则很容易出现未定义行为：
- 避免多次修改同一变量。单个表达式，只应该对一个变量修改至多一次。
- 避免同时读写变量。单个表达式，如果对变量进行了修改，就不要再读取它。

特别地，使用逗号分隔两个子表达式通常是安全的，它有良好的定序规则。

#### 详细规则
具体见 [求值顺序 - cppreference](https://en.cppreference.com/w/cpp/language/eval_order.html)。

一次完整的表达式求值，包含值计算和副作用两个操作。在同一个线程中，表达式的所有求值操作通过“先序”规则判定顺序。如果操作 A 先序于（sequenced before，也被翻译为“按顺序早于”）操作 B，那么在完成操作 A 以后才会开始执行操作 B。先序关系具有传递性。

如果表达式 A 先序于表达式 B，只有完成了 A 的值计算和副作用，才会开始进行 B 的值计算和副作用。

C++ 标准说明了几个确定的先序关系，详情可以参考上述链接。

绝大多数运算符，对左右操作数都是没有定序的。函数调用时，参数的求值顺序也是无序的（C++17 开始变为未指定行为）。

未定序的情况下，多次修改或者同时读写同一变量属于未定义行为。

例如这样的一个表达式 `i++ && ++i`，可以按照下文的方式来分析。（个人理解）

把表达式分为如下几个部分：
- `i++`：求值 `A0`，副作用 `A1`。
- `++i`：求值 `B0`，副作用 `B1`。
- 逻辑与：求值 `C0`。

用 `->` 表示先序关系，应用相关标准规则可知：
- `A0 -> A1`。
- `B1 -> B0`。
- `A -> B`，`A0 -> C`，`B0 -> C`。

所以这个表达式可以完全定序，`A0 -> A1 -> B1 -> B0 -> C`，不存在未定义行为。

相对地，`i++ + i` 这样的表达式也可以分析出是未定义行为。

### 杂项
#### 运算符优先级
见 [C++ 运算符优先级 - cppreference](https://en.cppreference.com/w/cpp/language/operator_precedence.html)。

#### “表达式”和“语句”
表达式（Expression）和语句（Statement）是两个可能被混淆的概念。

表达式用于计算并一个值，例如以下的几个表达式：
```cpp
a + b  // 简单表达式
(a - b) * ((a + b * c) << 2)  // 表达式可以嵌套和组合
2 * sqrt(2)  // 函数调用也是表达式
```

语句用于执行操作、控制程序运行等。它没有返回值。例如以下的几个语句：
```cpp
int x{100};  // 定义变量
for (int i = 0; i < 100; i++) {  // 循环语句
    if (i % 9 == 2)  // 条件语句
        continue;  // 控制语句
    x++;  // 执行表达式的语句
}
```

#### “短路”机制
逻辑与 `&&`、逻辑或 `||` 运算符有特殊的“短路”机制。它会先计算左侧的表达式，如果此时已经可以确定答案（`&&` 遇到 `false`，`||` 遇到 `true`），就不再计算右侧的表达式。

这个特性主要是用来方便这样的代码：
```cpp
bool flag = (index < n) && (a[index] >= 0); // 如果 index >= n，不会执行右侧导致未定义行为
```

#### 逗号运算符
可以使用逗号连接两个子表达式，其行为是依次执行这两个表达式，然后返回第二个表达式的值。

这在一些情况下可以方便书写。例如：
```cpp
// 尽管 for 循环的这个位置只能执行一条语句，但是可以用逗号表达式依次执行多个逻辑。
for (int i = 0; i < n; i++, cnt++) {}
```

#### 三目运算符
三目运算符可以执行条件判断，在一些情况下可以方便书写。

```cpp
int x = (n >= 0 ? 5 : 2);
// 等价于
int x;
if (n >= 0) { x = 5; }
else { x = 2; }
```

## 指针和引用
C++ 对象在内存上的存储，位于一个连续的地址空间。“指针”就是用于描述一个对象的地址。

可以把内存理解成一个大型的数组，“指针”存储的数据就是这个数组的下标（显然这是不严谨的，因为内存中可以存储不同类型的对象）。可以通过指针来读写对象。

### 指针基础
`T *p` 标识一个指向 `T` 类型对象的指针，名称为 `p`。接下来，通过 `*p` 可以访问 `p` 指向的元素（可以进行读写）。

`&x` 表示对 `x` 取地址，即获取一个指向 x 的指针。

例如以下示例：
```cpp
int x{100};
int *p = &x; // p 现在指向 x
*p = 24; // 通过指针间接修改
std::cout << x << '\n'; // 输出 24
```

类型 `T` 的部分可以包含 `const` 这样的修饰符，可以避免通过这个指针修改对象。

可以在星号后面添加 `const`，表示不可以修改“这个指针指向谁”。

例如：
```cpp
int x{10}, y{10};

int const *p1 = &x; // 等价于 const int *p1_
int * const p2 = &x;

*p1 = 100; // 错误！不能通过指针修改 const int
p1 = &y; // 现在 p1 指向 y
*p2 = 100; // 修改 x 的值
p2 = &y; // 错误！不能修改 p2 表示的地址。
```

指针必须指向一个合法的对象，并且是兼容的类型，否则对它解引用（`*p`）是未定义的。

### 常见的不可解引用指针
#### nullptr
C++ 使用 `nullptr` 作为空指针常量，语义上表示指针不指向任何元素。等于 `nullptr` 的指针不可解引用。

#### 悬空指针
当一个对象被销毁之后，指向它的指针就会变成悬空指针。一类典型的悬空指针是通过函数返回局部变量的指针。例如：

```cpp
int *f() {
    int tmp = 10;
    return &tmp;
}

int *p = f();
// 此时对 p 解引用，指向一个被销毁的局部变量，是未定义行为。
```

#### 无效指针
当一个指针指向无效的地址（通常是由于未初始化），对它解引用也是未定义的。

### 指针算术
指针可以进行一些简单的算术运算，如下：
- 指针加/减整数：将指针向前或者向后移动若干个元素。
- 指针减指针：计算它们间隔几个元素。
- 下标访问：`p[n]` 等价于 `*(p + n)`。

指针算术的单位始终是完整元素，而非字节。指针算术必须在同一个数组上进行（运算数的指针、结果的指针等），否则行为未定义。特别地，对于大小为 n 的数组，指向 a[n] 的指针也合法（尾后指针），但是不可解引用。

示例：
```cpp
int arr[100]{}; // 创建一片连续内存
int *p = &arr[5];
int *p1 = p + 5; // 指向 a[10]
int *p2 = p - 3; // 指向 a[2]
int dis = p1 - p2; // 等于 8
int item = p[9]; // a[14] 对应的值为 0
```

指针算术过程，涉及到的指针必须处于同一个数组中，否则行为未定义。

### （左值）引用
“引用”在本质上和指针类似，也是通过记录内存地址来关联到另一个对象。不同的是，引用：
- 无需显式解引用。
- 无法修改绑定到哪个对象。
- 必须在初始化时绑定。

例如以下代码：
```cpp
int x = 100;
int &y = x; // 定义一个 x 的引用，名为 y
std::cout << y; // 可以像一个整数一样直接使用 y
y = 10; // x 也被修改为 10
```

引用的类型也可以带有 `const` 修饰，和对应的指针相同，不能通过这个引用来修改原对象。特别地，`const T &` 可以绑定到一个右值（如字面量等）。

很多情况下，对于比较大的对象，我们会使用常量引用来传递参数，减少一次复制的开销。
```cpp
void print(const std::string &s) {
    std::cout << s << '\n';
}
```

## 函数
C++ 使用函数，可以把一段代码封装在一起，共同实现一个功能，进行一个计算。

### 基础知识
函数的基本用法，大家都已经很熟悉了，在这里不做讲述。

```cpp
int square(int x) {
    return x * x;
}

square(5); // 25
```

C++11 起，可以后置标注函数的返回值。这在编写一些使用模板的代码时会有帮助，并且可能更加美观。
```cpp
auto square(int x) -> int {
    return x * x;
}
```

C++14 起，返回值类型可以省略（仅使用 `auto`）。

### 函数重载
有些时候，我们可能会希望对多个类型实现类似功能，这种情况下就可以使用函数重载来实现，即允许多个函数拥有同一个名字。
```cpp
int square(int x) { return x * x; }  // (1)
double square(double x) { return x * x; }  // (2)

square(3);  // 调用重载 (1)
square(5.0);  // 调用重载 (2)
```

当调用存在重载的函数时，会通过重载决议判断实际调用哪一项。具体规则十分复杂，可以参考 [cppreference](https://en.cppreference.com/w/cpp/language/overload_resolution.html)。

简单来讲，需要满足以下要求：
- 首先，保证参数个数正确，并且模板推导成功、每个参数都可以隐式转换为相应类型。
- 对于这些可行项，按照以下优先级选择：
    1. 参数精确匹配。（允许左值到右值转换、限定符转换等简单转换）
    2. 只需使用标准转换，其中提升（如 `int` -> `long long`）优于其他转换（如 `double` -> `int`）。
    3. 需要用户定义的转换。（这允许从花括号包裹的初始化列表，转换为类类型）

对于相同优先级的，不带模板的函数优于带有模板的，函数模板之间按照特化程度比较。

如果无法判断两个重载的优先级，则编译错误。

### 默认参数
在函数声明中，可以为参数指定默认值，使得调用时可以省略部分参数。默认参数必须从参数列表的右侧开始连续指定。

```cpp
void print(int value, int base = 10, int width = 8) {}

print(42, 16, 4);
print(42, 16);    // 等价于 print(42, 16, 8)
print(42);        // 等价于 print(42, 10, 8)
```

存在默认参数的函数，会向重载决议添加多个重载项，例如上文的 `print` 会包括 `print(int)`、`print(int, int)` 和 `print(int, int, int)`。需要小心处理它和其他函数重载的潜在冲突。

### 重载运算符
C++ 允许重载运算符，允许自定义类型之间使用运算符进行操作，调用指定的函数。

定义一个重载运算符，可以使用 `operator` 关键字，形式大概相当于定义了一个叫做 `operator@` 的函数（`@` 是对应运算符）。

绝大多数运算符都可以被重载，以下是一个 `std::string` 乘以整数的重载。
```cpp
auto operator* (std::string const &s, int count) -> std::string {
    std::string res{};
    for (int i = 0; i < count; i++) res += s;
    return res;
}

// 使用
std::string s{"Hello"};  // 必须先转为 std::string
std::cout << s * 5 << '\n';
```

但是需要注意，重载运算符的操作数，不能全为内置类型，（例如这里包含一个 `std::string` 就是合法的）。

也可以在类的定义中，通过成员函数重载运算符（见相关章节）。

### 回调函数
有些时候，函数可以作为另一个函数的参数。这允许代码表达更加丰富的逻辑。

例如，我们有以下的两个需求：
- 找到 $[1, n]$ 的所有偶数，输出到控制台。
- 找到 $[1, n]$ 的所有偶数，存储到一个列表中。

这两个需求很明显十分接近，但是想要使用一个函数来实现，还是有一定的困难。事实上，我们可以提取一个共用的逻辑：找到该范围的所有偶数，通过某种方式提交结果。

那么我们便可以通过这种方式实现：传入整数 `n` 和另一个函数 `f`，每遇到一个偶数 `x`，通过调用 `f(x)` 提交这个答案。

我们使用 Python 语言来表达这个逻辑，因为 C++ 的类型系统可能比较复杂。如果你不了解 Python，可以看成伪代码结合注释理解。

```python
def find_even(n, f):  # 实现函数
    for i in range(1, n + 1):  # 遍历 [1, n] 区间
        if i % 2 == 0:
            f(i)  # 偶数，提交答案


def to_console(x):  # 输出到控制台
    print(x)


res = []  # 结果列表
def to_list(x):  # 输出到 res 列表
    res.append(x)

find_even(20, to_console)  # 使用
find_even(20, to_list)
```

想要在 C++ 中使用函数作为参数，可以考虑以下的方案。
#### 模板
**这是最推荐的方式**，通过模板，可以让函数接收任意类型的参数，自然包括函数。

这种方式不会有任何运行时的开销，并且可以完美支持下文提到的仿函数。

模板的相关知识会在后续章节讲解。

```cpp
template <typename T>
void find_even(int n, T f) {
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) f(i);
    }
}
```

#### 函数指针
在 C++ 中，可以让一个指针指向函数，称为函数指针。可以通过函数指针来调用这个函数。以下代码展现了函数指针的使用。

```cpp
#include <iostream>
#include <random>

int square(int x) {
    return x * x;
}

int cube(int x) {
    return x * x * x;
}

auto main() -> int {
    std::mt19937 random{std::random_device{}()};

    using FuncPointer = int (*)(int);  // 类型表示法：返回值 (*)(参数列表)
    FuncPointer ptr{};
    if (random() % 2 == 1) {  // 随机选择一个
        ptr = &cube;
    } else {
        ptr = square;  // 即使不使用取地址符号，函数名也会自动转换为函数指针
    }

    std::cout << ptr(6) << '\n';  // 函数指针可以直接使用括号调用，也可以先 (*ptr) 解引用再调用
    // 随机输出 36 或者 216
}
```

于是可以按照如下方式实现 `find_even` 函数。

```cpp
using FuncPtr = int (*)(int);
void find_even(int n, FuncPtr f) {
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) f(i);
    }
}

// 如果不使用类型别名，参数应写作 int (*f)(int)
```

这种方式无法支持仿函数和 lambda 函数，通常不推荐使用。但是函数指针也有其他的用途（例如上一个例子，以及与 C 函数交互等）。

#### std::function
`std::function` 是 C++11 起提供的一个标准库工具，可以存储一类可调用对象（函数或仿函数等），它们有相同的调用签名，即接收同样类型的参数、返回同样类型的值。

```cpp
#include <iostream>
#include <functional>

int square_impl(int x) {
    return x * x;
}

auto main() -> int {
    std::function<int(int)> square = square_impl;
    // lambda 函数也可以使用同样类型的 std::function
    std::function<int(int)> cube = [](int x) { return x * x * x; };
    std::cout << square(5) + cube(2) << '\n';  // 直接使用括号调用
    // 输出 33
}
```

`std::function` 像是适用范围更广的函数指针，在类型中只包括函数的调用签名。与之相对地，函数指针无法指向一个仿函数。

```cpp
void find_even(int n, std::function<int(int)> f) {
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) f(i);
    }
}
```

相比于使用模板，`std::function` 有较大的运行时开销，所以在函数传参的场景下，不建议使用这个方式。它更多用于实现运行时多态。

### 仿函数、lambda 函数
C++ 的函数无法在局部定义，这带来了很大的不便。这使得跨函数共享数据，只能通过参数传递，或者全局变量。

幸运的是，我们可以在局部定义域中定义一个类，并且可以通过成员函数重载函数调用运算符，即 `a(b)`。这使得我们可以通过这种方式模拟一个函数，这就是仿函数。

```cpp
auto main() -> int {
    struct Print {
        auto operator() (/*函数参数列表*/ int x) -> void {
            std::cout << x;
        }
    } print;

    print(0);  // 使用和普通函数一致
    return 0;
}
```

仿函数的意义不仅在于可以在函数内部定义，它还是一种有状态的函数。
```cpp
auto main() -> int {
    std::vector<int> vec{1, 2, 3, 4, 5};

    int sum{};
    struct Func {
        int &sum;
        auto operator() (int x) -> void {
            sum += x;
        }
    };
    Func func{sum};

    // 对 vec 的每个对象 x，调用 func(x)
    std::for_each(vec.begin(), vec.end(), func);

    return 0;
}
```

我们通过这种方式，可以在封装函数的同时，读写局部变量。这解决了“只能通过全局变量交换数据”的问题。

但是封装仿函数还是过于麻烦，所以 C++11 引入了 lambda 函数，作为更加方便的替代。lambda 在本质上还是基于仿函数实现。

定义一个 lambda 函数，分为以下三个部分：捕获列表，参数列表，函数体。
```cpp
auto lambda = [/*捕获列表*/](/*参数列表*/) { /*函数体*/ };
```

lambda 函数的类型无法表示（编译器自动生成），必须使用 auto 来接收它。此后可以使用 decltype 获取它的类型。每个 lambda 函数的类型都互不相同。

以上文的仿函数 `Func` 为例，它其实相当于“捕获”了局部变量 `sum`，从而可以对它进行读写。lambda 函数的捕获分为两种，按值捕获、按引用捕获。参考以下示例：

```cpp
auto main() -> int {
    int a{}, b{};

    [a]() { a = 4;  /* 错误，按值捕获不能修改 */ };
    [&a]() { a = 5; /* 按引用捕获，会同步修改外部的 a */ };
    [b, &a]() { /* 可以部分变量按值捕获，部分按引用捕获 */ };
    [&]() { a = 1, b = 2; /* 当前作用域内，全部按引用捕获 */ };
    [=]() { /* 全部按值捕获 */ };
    []() { global = 2; /* 全局变量，不进行捕获也可以读写 */ };
}
```

lambda 函数和普通函数的运行时开销相同，经过内联优化后均为零开销。

借助 lambda 函数，可以完美地解决一开始提到的问题。这使得我们可以方便地在函数内部封装子函数，无需依赖全局变量。消除全局变量，可以从根源上解决“多组测试忘记清空数组”这样的问题。

C++14 起，lambda 函数的参数列表可以使用 `auto` 代替参数类型，表示这个位置允许接收任意类型的参数。这个功能本质上是基于模板实现的。C++20 起，普通函数也添加了这个功能。例如 `sort` 的比较函数，现在可以这样写。
```cpp
std::sort(v.begin(), v.end(), [](auto x, auto y) { return x.a < y.a; });
```

lambda 函数的唯一问题可能是递归比较麻烦，无法直接支持递归。我常用的方法是，额外传递一个 `self` 参数，通过它进行递归调用。

```cpp
auto fac = [&](int x) { return x? x * fac(x - 1): 1; };  // 编译失败
auto fac = [&](int x, auto &self) { return x? x * self(x - 1): 1; }  // 个人常用的写法
std::function<int(int)> fac = [&](int x) { return x? x * fac(x - 1): 1; }  // 不推荐，有运行时开销
```

经过测试，这种函数递归写法的效率和普通函数递归没有差异。

## 类和结构体
有些情况下，我们需要处理几个关联很大的数据（例如分数的分子和分母），便可以封装一个类（class），把它们组合到一起统一管理。在 C++ 中，结构体和类几乎没有区别，通常可以混用。

### 类的基本使用
类的定义使用 `class` 或 `struct` 关键字。为了方便，我们先使用 `struct` 来定义类，后面会提到它们的区别。

```cpp
struct Frac {  // 分数
    // 数据成员
    int nume;  // 分子
    int deno;  // 分母
};
```

接下来，便可以把这个类作为一个独立的类型来使用。通过 `item.member_name` 可以访问它的数据成员。

```cpp
Frac x{};  // 值初始化
x.nume = 5;
std::cout << x.nume;  // 输出 5
```

我们可以通过先前提到的方式来初始化 `Frac` 的对象。例如 `Frac{2, 3}`（列表初始化），`Frac(4, 5)`（直接初始化），将会使用这些参数，按照声明顺序初始化类的成员。

对于一个指向 `Frac` 对象的指针，可以使用 `->` 运算符来访问成员。通常 `ptr->member` 可以看作和 `(*ptr).member` 等价。

```cpp
Frac x{3, 4};
Frac *ptr = &x;
std::cout << ptr->nume;  // 相当于 x.nume
```

### 成员函数
有些情况下，我们可能会写出这样的函数。
```cpp
void reciprocal(Frac &f) {  // 把 f 变成它的倒数
    std::swap(f.nume, f.deno);
}
// 使用：
Frac f{2, 3};
reciprocal(f);
```

C++ 支持“成员函数”，从而可以通过另一种方式来定义和使用这个函数。
```cpp
struct Frac {
    // ...
    void reciprocal() {
        std::swap(nume, deno);
    }
};
// 使用：
Frac f{2, 4};
f.reciprocal();
```

成员函数会在一个对象上进行操作，可以直接通过成员的名称，来访问当前对象上的成员。例如在 `f` 上调用 `reciprocal` 成员函数时，其中的 `nume` 就是 `f.nume`，`deno` 就是 `f.deno`。

成员函数中，还可以通过关键字 `this` 获得一个指针，指向当前对象。也可以使用 `this->nume` 这样的方式来访问成员。

成员函数也可以指定为 `const`，相当于普通函数传入常量引用，具体见以下的例子。
```cpp
struct Frac {
    void print() const {
        std::cout << this->nume << '/' << this->deno << '\n';
    }
};
// 等价于
void print(const Frac &f) {
    std::cout << f.nume << '/' << f.deno << '\n';
}
```

成员函数也可以是重载运算符。调用时，将会以自身作为第一操作数，参数作为后续操作数。部分特殊的重载运算符只能是成员函数。
```cpp
struct Frac {
    auto operator+ (Frac const &other) const -> Frac {
        return {nume * other.deno + deno * other.nume, deno * other.deno};
    };
};

// 使用
Frac{1, 2} + Frac{1, 3};  // Frac{5, 6}
```

#### 成员可访问性
从本质上讲，成员函数和普通函数几乎没有区别。那么它除了看起来比较好看，还有什么意义呢？

一些情况下，我们不希望一个对象的数据成员被外部程序修改（例如实现一个 `vector`，需要维护存储区的指针和大小，而随意修改它会严重威胁安全性）。

为了解决这个问题，C++ 引入了“成员可访问性”的概念。一个成员，可以指定在什么范围内可被访问。
- `public`：公开。这个成员可以被外部代码访问。
- `private`：私有。这个成员只能在当前类的内部访问。
- `protected`：受保护。这个成员只能在当前类，或者派生类的内部访问（关于“派生类”相关知识，见下文）。

通过以下方式指定成员的可访问性：
```cpp
struct A {
    int a1;  // 默认可访问性
    double a2;
private:
    char a3;  // 接下来都是 private
    long long *a4;  // private
public:
    int a5[3];  // public
};
```

默认可访问性取决于使用 `class` 还是 `struct` 关键字声明这个类。`struct` 则为 `public`，`class` 则为 `private`。

### 构造函数
构造函数是一类特殊的函数，当一个对象通过任何方式初始化的时候，会自动调用它的构造函数。构造函数负责给各个成员提供初始值。

```cpp
struct Frac {
    // ...
    Frac(int x, int y) :
            nume(x),  // 成员初始化器
            deno{y} {
        std::cout << "构造了一个 Frac 对象";
    }
};
```

声明构造函数时，函数名部分与类名相同，不能标注返回值类型。

构造函数分为成员初始化器和函数体两个部分。初始化器可以是任意初始化形式（直接初始化、列表初始化等）。初始化对象的时候，首先通过初始化器，**按照在类中的声明顺序**初始化所有成员，接下来开始执行函数体。

成员初始化器，其求值时的作用域和构造函数的函数体相同。简单来讲，它允许了以下操作：
```cpp
struct A {
    int x, y;
    A(int x, int y): 
            x(x), y(y) // 括号外的 x 和 y 是成员名，里面的是参数名
    {
        // 如同在函数体中使用 x 或 y，都是指代参数名
    }
};
```

除此以外，可以在声明成员的时候提供一个默认初始化器。当没有提供初始化器的时候，将会使用这个默认初始化器进行初始化。例如：
```cpp
struct Frac {
    int nume;
    int deno = 1; // 默认成员初始化器
    Frac(int x): nume(x) {}  // deno 将会初始化为 1
};
```

既没有没有初始化器、也没有默认初始化器的成员，会被执行默认初始化。也就是说，这可能导致部分成员**持有未定义的值或错误值**，或者在部分成员无法默认初始化的情况下，导致编译错误。更加致命的是，即使值初始化外层对象，这些被默认初始化的成员也不会赋值为零。

还有人会选择在构造函数的函数体中给数据成员赋值。这种方式可行但不推荐，提供初始化器是更加安全、便捷和高效的做法，尤其是对于复杂类型的成员。

通常情况下，建议给所有的成员都在声明时提供默认初始化器，例如值初始化 `member{}` 或者提供一个默认值 `member = 0` 来规避这个问题。

同一个类可以提供多个构造函数，通过重载决议区分。

有一些构造函数具有特殊的名字和语义，具体如下：
- `T()`：默认构造函数。用在值初始化等场合。
- `T(const T &)`：复制构造函数。用于复制一个对象。
- `T(T &&)`：移动构造函数。（涉及右值引用相关知识）

而且，这些构造函数通常都会被编译器自动生成，除非有成员不支持对应操作。

在 OI 中，很多情况都不需要给简单的结构体定义构造函数。根据聚合初始化相关规则，只有几个公开数据成员的结构体属于“聚合体”，可以直接用花括号形式初始化。详见前文相关章节。
```cpp
struct A {
    int x; double y; char z;
};
A a1{1, 2.0, 'c'}; // 正确
A a2{1, 2.0}; // 正确，等价于 {1, 2.0, '\0'}

// 函数传参
void f(A a, int x) { /*...*/ }
f({3, 4.0, '.'}, 0); // 正确
```

#### 显式构造函数
只接受一个参数的构造函数，可以用于隐式类型转换。但是我们可能并不希望这样。

```cpp
struct A {
    int x;
    A(int x): x(x) {}
};
void f(A x) { /*...*/ }

f(5); // 相当于 f(A{5});
```

这样会降低代码可读性，也会令人困惑。将构造函数声明为 `explicit` 即可避免这样的问题。标记为 `explicit` 的构造函数，不会用于函数传参、返回值、复制初始化等场景。

```cpp
struct A {
    int x;
    explicit A(int x): x(x) {}
};
void f(A x) { /*...*/ }

f(5); // 编译错误
```

建议单个参数的构造函数均使用 `explicit` 修饰，除非真的想要用于隐式转换。

以下案例可以演示 `explicit` 构造函数的重要性。
```cpp
#include <iostream>
#include <vector>

struct A {
    int x{}, y{};
    A(int x): x(x) {}  // 没有使用 explicit 修饰
    A(int x, int y): x(x), y(y) {}
};


auto main() -> int {
    std::vector<A> v;
    // vector 的 insert 可以接收一个 std::initializer_list 来插入多项
    // 此处相当于插入 A{2} 和 A{3}
    v.insert(v.begin(), {2, 3});
    std::cout << v.size() << '\n';  // 插入了 2 个元素
}
```

将单参数的构造函数设定为 `explicit`，则行为正常，只插入一个元素。这种情况下，希望插入两个元素，需要这样写：

```cpp
v.insert(v.begin(), {A{2}, A{3}});
```
