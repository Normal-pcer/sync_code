C++ 是许多信息学竞赛选手最熟悉的编程语言。日常训练中，我们可能只用到循环、数组这些基础功能，但这位朝夕相处的"老朋友"，其实藏着更多值得探索的奥秘。

也许你曾见过题解中神奇的语法"黑科技"，也许你被未定义行为导致的"玄学问题"困扰过，也许你面对突如其来的编译错误百思不得其解...

掌握这些知识，不会让你在赛场多拿几分，但能让你更加了解这个朝夕相处的代码伙伴。它们或许能帮你理解那些精妙的语言特性，或许能让你接触更现代的编程思维，又或许，只是满足你对技术世界的好奇心。

这个专栏并不是“语法大师课”，而是一次共同探索的旅程。我也只是一个 C++ 初学者，尝试分享自己理解中的一些点滴。

我们将从基础出发，逐步走进 C++ 的深处。虽然我的理解有限，无法覆盖那些艰深的内容。无论如何，都希望这些分享能为你打开一扇窗，了解一些可能平时了解不到的小知识，让你对这门语言多一分理解，这便是这篇专栏的最大意义。

# 前置知识

在正式开始之前，先来了解一些相关的概念。

## 编程工具

### 编译器

编译器是一种软件，负责将源代码编译成可执行文件。可执行文件（例如 Windows 系统的 exe 文件）可以被操作系统直接执行。

GCC（GNU Compiler Collection）是算法竞赛中最常用的 C++ 编译器。

代码编辑器负责帮助程序员编写代码。从定义上讲，记事本就可以算作编辑器。编辑器不负责代码的运行。

Sublime Text、Visual Studio Code 等都是常见的代码编辑器。

### 集成开发环境

集成开发环境（IDE）是一种集成了多种功能的工具，通常包含代码编写、编译运行、调试等功能。现代的代码编辑器，通过插件通常也能实现类似 IDE 的功能。

### 调试器

调试器可以帮助开发人员调试代码，通常包含断点（在程序运行到某处时停止运行）、逐行调试、查看变量值、检查运行时错误位置等功能。

gdb 是一个常用的调试器，并且**在 NOI Linux 的考试环境下可用**。

## C++ 标准

C++ 语言一直在发布新的标准，从 2011 年开始，每 3 年都会发布一个新标准。

当前的 C++ 标准有：C++98（C++03）、C++11、C++14、C++17、C++20、C++23，下一个标准是 C++26。

其中 C++03 只是在 C++98 的基础上做了简单的修订，并没有大幅度的更改。

本文讲述的内容，如果没有标注，默认是 C++98 就存在的。由于内容繁多，这部分标注可能存在遗漏，但是我会尽力保证所有 C++17 及以后的特性都标注出来（即不能在 NOI 系列考试中使用的）。

## 编译器优化（O2 优化）

大多数的现代编译器都提供了优化选项。在代码不存在未定义行为的情况下，编译器优化选项可以保证程序行为正确，并且优化代码的运行速度。

常见的优化选项有 `-O0`（无优化）、`-O1`、`-O2`、`-O3`、`-Ofast` 等，优化效果通常是递增的。

很多情况下，一些简单的优化在开启优化选项 `-O2` 之后，都会被编译器自动完成（例如简单函数调用造成的开销，绝大多数情况下都会被内联）。

开启编译器优化后，可能让存在问题的代码行为变得奇怪，同时会影响调试器的使用。所以在调试时建议禁用优化。

**目前，在 CCF 组织的比赛中，均使用 C++14 标准，开启 O2 优化。**

# 基础语法

## 输入输出

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello World!" << endl;
    return 0;
}
```

C++ 标准库中，主要有这几类输入输出方式：

-   C 风格的输入输出：`scanf`，`printf`，`getchar`，`putchar`，`puts` 等。
-   C++ iostream：`cin`，`cout` 等。
-   C++23 print：`print`，`println` 等。

在这些标准库提供的工具中，我最常用的是 iostream。它较为简单，并且可以保证类型安全，无需考虑占位符和实际类型的配套问题。而 C++23 的 print 尚未受到广泛支持。

iostream 采用重载的右移（有时又称“流输入”）和左移（“流输出”）运算符进行输入输出。代码如下：

```cpp
int x;
std::cin >> x;  // 输入
std::cout << x;  // 输出
```

`cout` 可以通过输出一些操纵符，来进行一定程度的格式化输出。大多数操纵符在头文件 `iomanip` 中定义。例如，如下代码可以保留 2 位小数输出：

```cpp
std::cout << std::fixed << std::setprecision(2) << 3.1415;  // 3.14
```

执行以上代码以后，接下来所有的浮点数输出都会维持这样的格式。

iostream 最大的问题可能就是它在默认情况下效率很低。**可以通过以下代码来加速**：

```cpp
std::ios::sync_with_stdio(false);
std::cin.tie(nullptr);
```

这种方法通常叫做“关闭同步流”，可以大幅度提升 cin 和 cout 的速度。

第一行的原理是，默认情况下 C 风格的输入输出会维护一个缓冲区来加速（即内容不会立即输出到屏幕，而是存到缓冲区中，缓冲区满或者手动刷新再一次性输出）。而 iostream 为了和 C 兼容，会在每一次输入输出时都刷新缓冲区，导致额外开销。调用了 `ios::sync_with_stdio(false)` 之后就不会每次刷新了。

第二行的原理是，默认情况下 cin 会和 cout 互相绑定，在每次使用 cin 输入时都刷新 cout 的缓冲区。这样可以避免交替使用输入输出时的额外刷新开销。

由于 `endl` 会刷新缓冲区，使用 `'\n'` 而不是 `endl` 换行也会加速输出。

经过这样优化的 `cin` 和 `cout`，速度会略快于 `scanf` 和 `printf`。

**关闭同步流的情况下，iostream 和 C 风格输入输出不能混用**。否则可能会导致多次输出的结果乱序。

有些时候，一些题目会要求输入不定量的信息。这种输入之所以可行，是因为从控制台输入信息，本质上是从一个虚拟的文件 `stdin` 输入。文件是有边界的，读到文件结尾就会获得 EOF 信息（End Of File），无法继续读入。

`cin` 可以通过 `cin.good()`（返回 `true`/`false`）来判断是否处于正常状态。同时 `cin.eof()` 可以判断是否到达文件末尾，`cin.fail()` 和 `cin.bad()` 可以判断是否出现其他的问题，例如读入的整数超过类型上限，或者期望读入整数实际读到字母，将会使得 `cin.fail()` 返回 `true`。

如果 `cin.good()` 返回 `false`，此时将会拒绝接下来的读取操作（变量将会保持原值不被修改）。

在条件判断中，`cin` 对象可以隐式转换为布尔值，即 `cin.good()`。可以通过以下代码来持续读入整数直到文件末尾。在控制台中运行时，可以按下快捷键 Ctrl+Z（Windows）或者 Ctrl+D（Linux）并换行，来手动输入一个 EOF。

```cpp
int x;
while (cin >> x) {  // cin/cout 输入输出之后返回自己
    cout << x << ' ';
}
```

## 未定义行为

接下来的代码中，将会涉及“未定义行为”及相关概念。可以参考 [cppreference](https://en.cppreference.com/w/cpp/language/ub.html) 页面。

C++ 的代码可能出现以下的错误类别：

-   **非良构**（ill-formed）。程序存在语法错误，或者可以诊断的语义错误。标准要求编译器对这种行为给出诊断信息，通常会导致编译错误。
-   非良构，但是不要求诊断（no diagnostic required）。有些情况下，程序存在语义错误，但是错误可能在链接时才能发现，或者进行诊断需要的代价过大。这类程序被执行，行为是未定义的。
-   **实现定义行为**（implementation-defined behavior）。程序在不同的实现中（包括编译器、标准库实现、运行时环境等），可能会有不同的行为。但是符合标准的实现需要在文档中说明每种行为的实际效果。
    -   例如，`long` 类型的大小是实现定义的。在常见的实现中，有些是 4 字节，有些是 8 字节。
-   **未指定行为**（unspecified behavior）。程序行为在不同的实现中有所不同，并且实现不需要说明这些行为的效果。
    -   例如，一些情况下的求值顺序，相同的字符串字面量是否指向不同地址。
    -   不应该依赖未指定行为。
-   **未定义行为**（undefined behavior，简称 ub）。程序的行为将不受任何限制。
    -   例如，数组的越界访问，有符号整数溢出，空指针解引用。
    -   实现无需对未定义行为进行诊断（因为有些只能在运行时被发现）。
    -   **未定义行为可能导致任何问题**，编译器也可以基于“程序不存在未定义行为”的假设进行优化。
    -   通常情况下，代码开启编译器优化前后行为不一致，就是由于存在未定义行为。

以下是几个编译器可能优化的例子：

```cpp
bool f(int x) {
    return x + 1 > x;  // 不溢出的情况下，整数 +1 一定大于自身
}
// 可能优化成：
bool f_(int x) {
    return true;
}
```

```cpp
int g(int *ptr) {
    int value = *ptr;  // 已经进行解引用，基于 UB 假设一定不是空指针
    if (ptr == nullptr) {
        return 0;
    } else {
        return value;
    }
}
// 可能优化成：
int g_(int *ptr) {
    return *ptr;
}
```

## 变量

```cpp
#include <iostream>
using namespace std;

int main() {
    int a, b;
    cin >> a >> b;
    cout << a + b << '\n';
    return 0;
}
```

C++ 的“变量”（Variable）是通过标识符引用的对象（Object），指向一个内存中的存储单元，持有的值可以改变。变量几乎是一切数值计算的基础。这个最简单的“两数和问题”中，我们就使用了变量进行计算。

### 变量名

变量名必须是一个合法的“标识符”（[Identifier](https://en.cppreference.com/w/cpp/language/identifiers.html)）。即有以下的要求：

-   首字符必须为英文字母 `A-Za-z` 或下划线 `_`，或其他具有 XID_Start 属性的 Unicode 字符。
-   其余字符必须为英文字母 `A-Za-z` 、数字 `0-9`或下划线 `_`，或其他具有 XID_Continue 属性的 Unicode 字符。

值得注意的是，自 C++11 起，绝大多数语言中的字母（例如中文汉字），甚至表情符号，都是合法的标识符（即上文提到的 Unicode 字符）。

除此以外，用户定义的标识符（变量、函数、类型等）不能与[关键字](https://en.cppreference.com/w/cpp/keyword.html)完全相同。以双下划线开头（如 `__reserved`），或者单下划线紧跟大写字母开头（如 `_Reserved`），行为是未定义的。

### 变量作用域

变量的作用域主要分为局部作用域和命名空间作用域等。

在函数等花括号（`{}`）包裹的代码块中定义的变量，具有局部作用域。局部作用域的变量，自声明后开始可见，直到代码块结束。

在命名空间中声明的变量，具有命名空间作用域。这类变量自声明后开始，在命名空间内始终可见，或者通过命名空间名来访问（`ns::name`）。全局作用域可以看作一个特殊的命名空间作用域，它自声明后开始，在全局内始终可见。

不同作用域的同名变量存在“遮蔽”原则，内层作用域的同名变量会隐藏外层作用域的变量。

```cpp
#include <iostream>
int x = 0; // 全局变量
int main() {
    std::cout << x << '\n'; // 输出 0
    int x = 1; // 局部变量将会遮蔽全局的 x
    std::cout << x << '\n'; // 输出 1
    std::cout << ::x << '\n'; // 可以通过 ::x 强制指定全局作用域的 x，输出 0
    return 0;
}
```

可以根据以上代码理解这些原则。

类型、函数等的作用域规则，也和变量相同。

### 存储期

存储期（Storage duration）指定了一个对象的生命周期，即在何时被销毁并回收资源。变量的存储期由定义的方式决定。

C++ 有以下的几种存储期：

-   自动存储期。这是局部变量的默认存储期，会在离开自己的作用域后自动销毁。
-   静态存储期。这是命名空间作用域（包括全局作用域）变量的默认存储期，在程序结束后销毁。
-   动态存储期。通过 `new`、`malloc` 等方式在堆空间动态分配对象的属于动态存储期，需要通过配对的解分配函数来销毁。
-   线程存储期。对于多线程程序，这类对象对每一个线程都会有一个独立的值，生命周期与这个线程相同。

有对应的说明符可以指定存储期。

-   `auto`：**C++11 起含义改变**。此前表示自动存储期。
-   `register`：**在 C++17 起被移除**。此前用于请求编译器把这个值存储在寄存器中，这个请求可以被忽略。
-   `static`：静态存储期。
-   `thread_local`：线程存储期。
-   `extern`：用于声明一个变量（而不是定义），链接到一个外部的来源。

`mutable` 关键字在 cppreference 中被归类为存储说明符，但是实际不会影响存储期，所以不在此讲述。

尽管 `register` 关键字直到 C++17 才被移除，但是即使在更早的标准中，编译器通常也会忽略它。不要试图使用这个关键字优化性能，这不会有任何作用。

自动存储期的对象将会存储在“栈空间”中，栈空间的容量有限（通常为 8MB），所以定义一些较大的数组，或者递归层数过深，都可能会出现“爆栈”的问题。但是大部分 OJ 和比赛环境，以及 CCF 组织的比赛中，允许程序使用无限的栈空间（即与程序总体内存限制相等），这些情况下可以放心使用局部数组和递归（局部数组需要手动初始化）。

如果想要设置无限栈空间，可以通过如下方式：

-   对于 Windows 系统，编译选项（GCC 为例）添加 `-Wl,-stack=2147483647`。
-   对于 Linux 系统，运行程序前在终端执行 `ulimit -s unlimited`。

全局或命名空间作用域的静态变量，将会在调用主函数之前进行初始化。

可以在局部作用域中通过 `static` 关键字来定义一个静态变量，这个变量将仅会在第一次运行到定义处的时候进行一次初始化，接下来每次使用都会保有一个相同的值。可以结合以下代码理解。

```cpp
#include <iostream>

void f() {
    static int count = 0;
    count++;
    std::cout << count << ' ';
    // 静态变量的值不会被清除
}

int main() {
    f(); f(); f(); // 输出 1 2 3
    return 0;
}
```

### 变量初始化

定义一个变量的同时会进行初始化，赋予其一个初始值。C++ 的变量初始化规则十分复杂，接下来我们将会进行一些简单的讲解。

本章节中可能会涉及一些后续章节才出现的知识。如果出现了你不理解的内容，可以暂时忽略。

在章节的结尾，将会有一段简要的总结。你也可以通过这段总结来理解。

#### 零初始化

零初始化（[Zero-Initialization](https://en.cppreference.com/w/cpp/language/zero_initialization.html)）是将对象逐位赋值为 0 的初始化方式。C++ 中没有专用的零初始化语法，但是其他初始化方式可能包含零初始化。

**所有具有静态存储期的变量**，将会在进行其他初始化之前，先进行一次零初始化。平时常见的结论“全局变量会自动赋值为 0”就是来自这条规则。

#### 默认初始化

默认初始化（[Default-Initialization](https://en.cppreference.com/w/cpp/language/default_initialization.html)）是在没有指定初始化器时的初始化方式。例如以下场景将会执行默认初始化：

```cpp
int x;
auto *ptr = new double;
```

另外，在类的构造函数中，没有在初始化列表中提及的成员，也会执行默认初始化。

```cpp
struct A {
    int data;
    A() {}
};
A p;  // p.data 将会执行默认初始化
```

对类型 `T` 进行默认初始化的效果如下：

-   如果 `T` 是类类型（Class Type，由 `class`、`struct` 或 `union` 关键字定义的类型），则调用默认构造函数（空参数列表），为对象提供初始值。
-   如果 `T` 是数组类型，对数组的每个元素进行默认初始化。
-   否则，**不额外执行初始化**。

**对象在未执行初始化的情况下，将会持有一个不确定的值**，直到这个值被替换。使用这个不确定的值进行任何求值操作，都是未定义行为。

但是由于静态存储期的对象会预先进行一次零初始化，所以这种写法对它们是安全的。

C++26 起规定，对于一个自动存储期的变量，并且没有被标识 `[[indeterminate]]`，将会有以下行为：

-   构成该对象存储的所有字节，填充一个错误值。这个错误值由实现定义，但是与程序状态无关。
-   如果使用错误值进行求值操作，则行为是错误行为（Erroneous Behavior）。错误行为仍然应该被视作不正确的结果，但是标准建议实现对错误行为进行诊断，而非像未定义行为一样假设不会存在并促进优化。

C++26 引入的错误填充值，往往会导致未初始化的对象拥有一个异常值（例如无效指针，或者绝对值很大的整数和浮点数），避免由于“不确定值”有时恰好符合期望，而产生偶发性的错误。

`const` 对象不允许默认初始化。

#### 值初始化

值初始化（[Value-Initialization](https://en.cppreference.com/w/cpp/language/value_initialization.html)）在使用空初始化器构造对象时执行，以下是几种常见的场景：

```cpp
int x{};
auto *ptr = new double();
std::cout << float() /*构造临时对象*/ << '\n';
char arr[100]{};
```

下文中用 `T` 代指对象类型。

有以下特例：

-   如果 `T` 是聚合类型（见下文“聚合初始化”），那么执行聚合初始化。但是这种情况下聚合初始化的行为与值初始化的效果是一致的。
-   如果 `T` 没有默认构造函数，但是有一个接收 `std::initializer_list` 的构造函数，那么执行列表初始化。

值初始化的效果如下：

-   如果 `T` 是类类型，那么：
    -   如果它的默认构造函数不是用户提供的（即自动生成），先执行零初始化。
    -   接下来，执行默认初始化。
-   否则，如果 `T` 是数组类型，值初始化每个元素。
-   否则，对象将会被零初始化。

值初始化在大多数情况下可以保证所有元素被正确初始化（一个反例为上文“默认初始化”章节的 `p.data`）。

#### 聚合初始化

聚合初始化（[Aggregate-Initialization](https://en.cppreference.com/w/cpp/language/aggregate_initialization.html)）是通过初始化列表来初始化聚合类型的过程。这是一种特殊的列表初始化。

##### 聚合类型

聚合类型（Aggregate）是以下类型之一：

-   数组类型
-   符合以下要求的类类型
    -   没有用户声明或继承的构造函数。（C++20 起，此前的要求类似，但是略有不同）
    -   没有私有（private）或受保护（protected）的非静态数据成员。
    -   没有虚基类（virtual），没有私有或受保护的基类。（C++17 起，此前要求没有任何基类）
    -   没有虚成员函数。
    -   C++11 及以前的版本，还要求没有默认成员初始化器（Default Member Initializers，即在声明成员的同时赋默认值）。

##### 指派初始化器

C++20 引入了指派初始化器（Designated Initializers），可以通过成员名称和目标值之间的键值对来进行聚合初始化。

```cpp
struct A { int a; double b; };
A a{.a = 5, .b = 9.0};  // 指派初始化器
```

##### 窄化转换

窄化转换是有潜在精度丢失的转换方式。目标类型不能存储源类型的所有值时，视为窄化转换（例如 `double` 到 `int`，`long long` 到 `int`）。

在标准禁止窄化转换的操作中，部分编译器可能实现为仅视为警告，不拒绝编译。

##### 初始化流程

聚合初始化可以分为显式初始化（explicit）和隐式初始化（implicit）。

首先，确定需要显式初始化的元素：

-   如果初始化列表是指派初始化器，则包含对应的所有成员。
-   否则，按照声明顺序包含最靠前的若干个元素。如果一个成员 `x` 也是聚合体，并且实际传入的值不是聚合体，将会进一步匹配 `x` 的全体成员，再对 `x` 进行聚合初始化，减少一层花括号嵌套。

```cpp
struct A { int x = 0, y = 0, z = 0; };
A arr[2] {0, 1, 2, 3, 4, 5};  // 相当于 {{0, 1, 2}, {3, 4, 5}}
```

如果 `T` 为联合体（union），包含超过一个显式初始化的元素，程序非良构；若是使用指派初始化器，则只能指定一个成员。

接下来，按照声明顺序初始化这些选中的元素。初始化每个成员时相当于使用复制初始化。

接下来，如果 `T` 不是联合体，每个未显式初始化的成员按照以下方式隐式初始化：

-   如果这个元素有默认成员初始化器，从初始化器初始化它。
-   否则，如果元素不是引用，从空的初始化列表对它进行拷贝初始化（多数情况下等价于值初始化）。
-   否则，程序非良构。

特别地，通过字符串字面量初始化一个字符数组，也属于聚合初始化。允许的字符类型有：`char`（或 `signed` 和 `unsigned` 变种）、`wchar_t`、`char16_t`（C++11 起）、`char32_t`（C++11 起）和 `char8_t`（C++20 起）。数组过长的部分将用 0 填充。

聚合初始化的过程中，不允许对参数进行窄化转换。

```cpp
char s[30]{"This is a C-style string."};
```

#### 列表初始化

通过花括号包裹的初始化列表初始化对象的方式，叫做列表初始化（[List-Initialization](https://en.cppreference.com/w/cpp/language/list_initialization.html)）。

```cpp
std::pair<int, int> p = {1, 2};
std::vector<int> v{0, 1, 2, 3};
```

类似以上方式的初始化，属于列表初始化。

上下两种方式，以语义上是否需要紧跟一次复制为分别，又称为“复制列表初始化”和“直接列表初始化”。例如，向函数参数传递一个初始化列表，或者将初始化列表作为返回值，都属于“复制列表初始化”。经过编译器优化，这种方式通常不会有额外的复制开销，

复制列表初始化，不会调用标记为 `explicit` 的构造函数。

列表初始化有以下的流程：

-   如果初始化列表是指派初始化器，执行聚合初始化。
-   如果 `T` 为聚合类型，并且初始化列表提供了一个同类型的对象，则从这个对象初始化。（依据自身类别进行复制初始化/直接初始化）
-   如果 `T` 为字符数组，且用花括号括起来一个对应的字符串字面量，则由这个字符串进行聚合初始化。
-   如果 `T` 为聚合类型，执行聚合初始化。
-   如果初始化列表为空，且 `T` 为存在默认构造函数的类类型，执行值初始化。
-   如果 `T` 为 `std::initializer_list` 的特化，逐个成员复制初始化。
-   如果 `T` 为类类型，考虑其构造函数：
    -   接受单个 `std::initializer_list` 参数的构造函数，优先调用。
    -   对于初始化列表中指定的参数执行重载决议，寻找最佳匹配的构造函数。
-   否则（`T` 不是类类型），并且初始化列表中只有一项，并且 `T` 不是引用，或者 `T` 是兼容的引用（同类型或是其基类），则从这个对象初始化，但是不允许窄化转换。
-   否则，如果 `T` 是不兼容的引用类型，将会通过复制列表初始化创建一个 `T` 所引用类型的临时量，然后引用绑定到这个临时对象。如果 `T` 是非 `const` 的左值引用，那么操作失败。
-   否则，如果初始化列表为空，执行值初始化。

初始化列表中，求值顺序是固定的从前到后。相对地，**函数调用的参数求值顺序是不固定的**。

##### std::initializer_list

`std::initializer_list` 可以存储若干个类型相同的对象。列表初始化中，将会优先使用接受 `std::initializer_list` 的构造函数。

例如，通过花括号初始化存在若干个初始元素的 `std::vector`，就是通过 `std::initializer_list`。

```cpp
std::vector<int> vec{0, 1, 2, 3, 4};
```

#### 复制初始化

复制初始化（[Copy-Initialization](https://en.cppreference.com/w/cpp/language/copy_initialization.html)）指从另一个对象初始化一个对象，在语义上应该发生复制。

```cpp
int x = y;
f(x);  // 函数调用时也是复制初始化
```

-   如果初始化器的类型为 `T`，调用 `T` 的构造函数。
-   初始化器类型与 `T` 无关，则尝试调用：
    -   初始化器类型的转换函数，转换为 `T` 或派生类。
    -   `T` 的构造函数，接受初始化器类型。
-   尝试应用标准转换。

复制初始化中，不会使用任何标记为 `explicit` 的构造函数。有些情况下的复制往往可以被编译器优化掉，转换成直接在目标位置构造对象。

C++17 起，标准强制要求进行复制消除，即初始化器为函数返回值这样的纯右值时，一定不会进行额外的复制。此前的编译器往往也会做这样的优化。

#### 直接初始化

直接初始化（[Direct-Initialization](https://en.cppreference.com/w/cpp/language/direct_initialization.html)）通过指定的参数调用构造函数，初始化对象。

```cpp
std::vector<int> vec(/*n:*/10, /*default:*/2);
```

直接初始化的效果如下：

-   如果 `T` 是数组类型：
    -   C++20 起，数组按照聚合初始化的方式进行初始化，但允许进行窄化转换，并且任何没有初始化器的元素将进行值初始化。
-   如果 `T` 是类类型：
    -   C++17 起，标准规定实现类似复制初始化的“复制省略”机制，如果参数是 `T` 的纯右值，直接使用初始化器本身初始化目标对象。
    -   检查 `T` 的构造函数，通过重载决议决定最佳匹配项。
    -   C++20 起，如果 `T` 是聚合类型，使用类似聚合初始化的方式进行初始化。但是存在以下区别：允许窄化转换，不存在花括号省略机制，没有初始化器的元素将会执行值初始化。
-   否则（`T` 不是类类型），源类型是一个类类型，则会检查其转换函数。
-   否则，如果 `T` 为 `bool` 且源类型为 `std::nullptr_t`，初始化对象为 `false`。
-   尝试应用标准转换。

以下的写法是错误的，因为会和函数声明混淆。这通常可以使用空的花括号代替。

```cpp
std::vector vec(/*参数列表为空*/);
```

#### 总结

核心规则可以大致概括为：

-   零初始化：逐位赋值为 0，全局/静态变量自动执行。
-   默认初始化 `int x`：
    -   类类型，调用默认构造函数。
    -   基本类型，**局部变量的值不确定**，全局/静态变量预先零初始化为 0。
-   值初始化 `int x{}`：
    -   基本类型，初始化为 0。
    -   类类型，调用默认构造。
    -   通常是最安全的初始化方式。
-   直接初始化 `int x(5)`：
    -   直接调用匹配的构造函数。
-   复制初始化 `int x = 5`：
    -   实际行为通常与直接初始化一致。
    -   禁用 `explicit` 构造函数。
    -   经过编译器优化，通常不会有额外的复制。
-   列表初始化 `int x{5}`：
    -   优先匹配接受 `std::initializer_list` 的构造函数。
    -   禁止窄化转换。

### cv 限定符（常量性、易变性）

类型可以通过 `const` 和 `volatile` 修饰，获得常量性或者易变性。修饰符不会影响对象的底层表示、对齐要求等。

数组类型与它的元素拥有相同的 cv 限定符。

对象具有的 cv 限定符，也会给予它的成员。被声明为 `mutable` 的成员除外，它不会继承对象的常量性。

#### 常量性

具有常量性的对象不能被修改。直接修改会导致编译错误，而间接修改（例如通过 `const_cast` 获得非常量指针，或者直接修改底层内存）**会导致未定义行为**。

#### 易变性

具有易变性的对象，每次读写都要求立即和内存同步，禁止编译器进行缓存、指令重排等优化。在涉及信号处理、系统中断、直接操作内存等情况下需要用到。编译器会假设代码始终单线程执行，从而在一些情况下，可能导致意料之外的优化。

## 类型

### 基本类型

C++ 包含以下的[基本类型](https://en.cppreference.com/w/cpp/language/types.html)：

-   整数类型
-   浮点数类型
-   `std::nullptr_t` 空指针类型
-   `void` 空类型

#### 整数类型

有以下对于整数类型的长度修饰符。长度修饰符的效果由实现定义，但是需要满足一定要求。

| 长度修饰符 | 要求         |
| ---------- | ------------ |
| short      | 不小于 16 位 |
| (无)       | 不小于 16 位 |
| long       | 不小于 32 位 |
| long long  | 不小于 64 位 |

完整的整数类型包含以下部分：

| 组成部分   | 描述                                                          |
| ---------- | ------------------------------------------------------------- |
| 长度修饰符 | 指定数字位数要求                                              |
| 符号标识符 | 指定数字有符号（`signed`）/无符号（`unsigned`），不填为有符号 |
| `int`      | 如有其他的单词描述，可以省略                                  |

这几个部分的顺序可以交换，`signed short int`、`long long unsigned int`、`long int signed` 都是合法的。

除了以上的标准整数类型，还有以下的整数类型：

-   布尔类型 `bool`。
-   字符类型。
    -   `signed char`，`unsigned char`。
    -   `char`。以上三个类型的长度相同，但是始终是三个不同类型。`char` 是否有符号由实现定义。
    -   `wchar_t`，`char16_t`（C++11 起），`char32_t`（C++11 起），`char8_t`（C++20 起）。
-   扩展整数类型。
    -   GCC 扩展的 `__int128` 就是扩展整数类型。

此外，标准保证 `sizeof(char)` 为 1，且 `sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long)`。`sizeof` 返回值的单位为字节，字节的位数由实现定义，但是绝大多数情况下都是 8 位。

#### 浮点数类型

-   `float`。单精度浮点数，通常为 IEEE-754 binary32 格式。
-   `double`。双精度浮点数，通常为 IEEE-754 binary64 格式。
-   `long double`。扩展精度浮点数。
-   由实现定义的扩展浮点数类型。

浮点数不一定映射到 IEEE-754 规定类型。它的精度和占用空间都是实现定义的。大多数实现下，`float` 和 `double` 都是遵循 IEEE-754 的规定，而 `long double` 的实现则更加多样。

### 类型转换

C++ 的类型转换分为隐式（implicit）和显式（explicit）的。

#### 隐式类型转换

当一个类型在上下文中不适用，但是可以转化为一种合适的类型时，就会发生隐式类型转换。

例如希望给一个 `bool` 类型的变量赋值，但是传入了一个 `int`，就会出现一次隐式转换（0 变为 `false`，非 0 值变为 `true`）。

隐式类型转换可以由以下的步骤组成：

-   零个或一个标准转换序列。
-   零个或一个用户定义的转换。
-   如果使用了用户定义的转换，还可以接受零个或一个标准转换序列。

传递给构造函数的参数，或者在两个非类类型之间转换，只允许标准转换。

一个标准转换序列，包括以下组成部分：

-   从以下集合中选择零个或一个转换：
    -   左值到右值转换。
    -   数组到指针转换。
    -   函数到指针转换。
-   零次或一次数值提升或数值转换。
-   零次或一次函数指针转换。
-   零次或一次限定符转换。

用户定义的转换，包含接受单个参数的构造函数，或者转换函数。但是二者都不能标记为 `explicit`。例如以下代码可以支持 `int` 到 `A`、`A` 到 `bool` 的隐式类型转换。

```cpp
struct A {
    int value{};
    A() {}
    A(int x): value(x) {}

    operator bool() const noexcept {
        return value != 0;
    }
};

A a = 5;
bool flag = a;
```

##### 值类别

在上文中提到了左值和右值的概念，我们在此处先简单地介绍一下。

C++ 的表达式分为纯右值（prvalue）、将亡值（xvalue）和左值（lvalue）这三大类。这里只介绍纯右值和左值。

左值和右值，这个名称最初的意味是“左值可以出现在赋值运算符的左侧”。尽管现在不是这样，在某些情况下，左值有可能无法赋值，右值有可能允许赋值。

左值用于确定一个已经被存储的特定对象或者函数。例如变量 `a`，数组访问 `arr[0]` 都是左值。

纯右值是没有持久存储的临时值，例如：

-   字面量，如 `1`，`3.4`，`'c'`。（字符串字面量除外）
-   算术表达式结果，如 `a + b`。
-   函数调用结果（不返回引用），如 `std::sqrt(4)`。

##### 实例

例如以下代码：

```cpp
#include <iostream>
#include <string>

int main() {
    struct A {
        int value{};
        A() {}
        A(int value): value(value) {}

        operator int () const {
            return value + 1;
        }
    };

    A a{5};
    bool flag = a;
}
```

以上代码 `bool flag = a` 一句，通过以下途径转换：

-   一个标准转换序列。包含左值到右值的转换。
-   一个用户定义的转换。调用转换函数 `operator int`。
-   一个标准转换序列。包含 `int` 到 `bool` 的数值转换。

##### 上下文相关转换

一些语境下期望的类型为 `bool`，此时进行隐式类型转换，效果相当于显式类型转换 `static_cast<bool>(x)`。

-   `if`、`while`、`for` 的条件表达式。
-   **内置运算符** `!`、`&&`、`||` 的操作数。
-   条件运算符 `?:` 的第一个操作数。
-   `static_assert`、`noexcept`、`explicit` 的条件表达式。

#### 显式类型转换

C++ 中的显式类型转换，通过以下几类关键字进行。将 `x` 转换为 `T` 类型的方法是 `static_cast<T>(x)`（或使用其他关键字）。

-   [static_cast](https://en.cppreference.com/w/cpp/language/static_cast.html)，适用于一些较为安全的转换，例如：
    -   基础类型间的数值转换。
    -   基类、派生类指针之间互相转化。
    -   将 `void *` 转化为具体类型指针。
    -   `static_cast<void>` 用来丢弃一个值。
    -   调用构造函数、转换函数。（允许使用 `explicit`）
-   [reinterpret_cast](https://en.cppreference.com/w/cpp/language/reinterpret_cast.html)，根据底层内存重新解释对象，例如：
    -   指针和整数互相转换。
    -   无关类型的指针之间互相转化（不能移除 `const`/`volatile`）。
-   [const_cast](https://en.cppreference.com/w/cpp/language/const_cast.html)，适用范围：
    -   对于带有 `const`/`volatile` 修饰类型的指针，可以移除修饰符。
-   [dynamic_cast](https://en.cppreference.com/w/cpp/language/dynamic_cast.html)，适用于多态类型带有运行时检查的转换。此处不做提及。

滥用 `reinterpret_cast` 和 `const_cast` 极易引起未定义行为。原对象为 `const` 时，通过 `const_cast` 去除 const 修饰符之后再修改，**仍然属于未定义行为**。它通常只能用于和接受非常量指针的函数交互，并且可以保证不会真的修改传入内容。

`reinterpret_cast` 可以获得任意类型的指针，但是对这个指针进行解引用，必须保证**目标类型有合适的可访问性**，否则**仍然属于未定义行为**。`T` 只能通过以下的类型被访问：

-   `T` 本身。
-   如果 `T` 为整数类型，`T` 对应的有符号/无符号版本。
-   `char`、`unsigned char`、`std::byte`。这允许通过字符数组来观察对象在内存中的表示。

例如：

```cpp
double x = 5;
using u64 = std::uint64_t;

u64 x1 = *reinterpret_cast<u64 *>(&x);  // UB
u64 x2; std::memcpy(&x2, &x, sizeof(u64));  // memcpy 逐字节复制是安全的
u64 x3 = std::bit_cast<u64>(x);  // std::bit_cast 是 C++20 引入的安全转换方式

union { u64 int_; double double_; } tmp;
tmp.double_ = x; u64 x4 = tmp.int_; // UB；union 不可以访问错误成员
```

使用括号包裹一个类型名，随后接一个表达式，叫做 C 风格类型转换。C 风格转换支持上述所有的转换方式。现在 C++ 中，出于安全性考虑，**不推荐使用这种类型转换**。例如 `(int)3.0`、`(double)(a + b)`。

一些类型后可以接一个括号，传入参数进行类型转换。这种转换方式本质上是对象的直接初始化，但有时会被称为“函数式转换”。例如 `char(32)`，`std::string("test")`。

### 类型别名

C++ 中，可以为类型声明别名，用于简化代码。类型别名和原类型在各种方面都是完全相同的，不会创建新的类型。

#### `using` 类型别名

C++11 引入了 `using` 关键字作为声明类型别名的含义，这也是现在 C++ 推荐的声明方式。用法如下：

```cpp
using i64 = long long;
```

这个语句为 `long long` 声明了一个类型别名 `i64`。

类型别名也适用和变量相同的作用域规则。

`using` 声明别名最大的特点是它可以支持模板。

#### `typedef` 类型别名

`typedef` 声明类型别名的方式与变量相似，源类型在前，别名在后。

```cpp
typedef long long i64;
```

### 字面量类型

C++ 中，所有字面量的类型都是确定的。

#### 整数字面量

通常情况下，一个整数类型字面量的类型通过如下简化规则确定（完整表格见 [cppreference](https://en.cppreference.com/w/cpp/language/integer_literal.html)）。

-   默认情况下为 `int`。如果数字过大，超过 `int` 存储范围，向上依次尝试 `long` 和 `long long` 类型。
-   如果使用了 `U` 后缀，则选定数字的无符号版本。
-   如果使用了 `L` 后缀，则从 `long` 开始尝试。如果使用了 `LL` 后缀，则从 `long long` 开始尝试。

`U` 后缀可以和其他的后缀组成 `UL` 或者 `ULL`。后缀大小写不敏感，但是 `LL` 的两个字母形式必须相同。

特别地，二进制、八进制或者十六进制表达，即使没有指定 `U`，也会尝试选定无符号类型。

例如以下的整数字面量（假设 `int` 和 `long` 为 32 位，`long long` 为 64 位）：

```cpp
5; // 默认为 int
2'147'483'648; // 超过 int 和 long 最大值，为 long long
100LL; // 手动指定为 long long
24llU; // 与大小写、顺序无关，为 unsigned long long
0x80000000;  // unsigned int
```

#### 浮点数字面量

浮点数字面量的类型由后缀决定。

-   无后缀，表示 `double`。
-   `f` 后缀，表示 `float`。
-   `l` 后缀，表示 `long double`。

同样对大小写不敏感。

### 字符串字面量

字符串字面量的类型是对应的常量字符数组。例如 `"Hello"` 的类型是 `const char[6]`（包含结尾的空字符）。

#### 原始字符串

C++11 引入了原始字符串语法。类似 `R"$(content)$"` 的形式为一个原始字符串，其实际值和 content 相同，并且无视转义字符，可以换行。其中的美元符号可以换为任意字符串（也可以为空），它不会出现在真正的内容中。例如：

```cpp
std::cout << R"raw-str(\\\\ ()() """"
\n\n\n\n)raw-str";
```

得到如下输出：

```
\\\\ ()() """"
\n\n\n\n
```

原始字符串的行为和普通的字符串相同。

### 自动类型推导

#### `auto`

C++11 起，[auto](https://en.cppreference.com/w/cpp/language/auto.html) 关键字用作自动类型推导。

变量初始化时，可以使用 `auto` 来代替实际类型。推导类型时有以下规则：

-   忽略初始化表达式的引用性。
-   如果类型说明符不带引用，忽略初始化表达式的 cv 限定符。
-   如果类型说明符是 `auto &&`，根据初始化表达式的类别，推导为左值引用或右值引用（见相关章节）。

例如以下代码：

```cpp
const int x = 10;
auto x1 = x; // x1 的类型为 int，不带 const
volatile auto x2 = x; // x2 的类型为 volatile int，也不带 const
auto &x3 = x; // x3 的类型为 const int &，引用类型保留 const
auto x4{x}; // 各种初始化方式都可以使用 auto
```

C++20 起，`auto` 也可以用于函数参数类型。例如以下代码：

```cpp
auto add(auto a, auto b) { return a + b; }
// 等价于
template <typename Ta, typename Tb>  // 详见模板章节
auto add_(Ta a, Tb b) { return a + b; }
```

lambda 函数自 C++14 起就有类似特性。

#### `decltype`

C++11 起，可以用 `decltype` 推断表达式的类型。

如果参数是一个实体（Entity，如没有括号包裹的变量名、函数名、成员访问表达式），`decltype(entity)` 返回它的类型。

否则，如果参数是类型为 `T` 的其他表达式，基于其值类别：

-   `prvalue`，产生 `T` 类型。
-   `lvalue`，产生 `T &` 类型。
-   `xvalue`，产生 `T &&` 类型。

被 `decltype` 包裹的表达式不会被真正执行。

例如：

```cpp
int x;  // 未初始化
using T1 = decltype(x);  // int
using T2 = decltype((x));  // 此时为表达式，int &
using T3 = decltype(x + 1.0);  // double
// 没有真正使用 x 的值，所以不是 UB。
```

## 数值计算

算术运算等数值计算，算是最常用的操作了。接下来，我将会介绍一些和数值计算相关，可能被忽视的小细节。

### 类型转换

在进行数值计算之前，需要把两个操作数转换为相同类型。

对于整数运算，将会从下表中选定第一个可以同时表示两个操作数的类型，将二者同时转换为这一类型。

-   `int`
-   `unsigned int`
-   `long`
-   `unsigned long`
-   `long long`
-   `unsigned long long`

算术运算的结果类型，和这个转换后的类型相同。例如：

-   `int + long long` -> `long long`
-   `char + char` -> `int`

关于浮点数的运算具有相似的规则，将会把整数转换为浮点数、浮点数转换为精度较高的。例如：

-   `int + float` -> `float`
-   `float + double` -> `double`

一个常见的错误是，STL 容器的 `.size()` 方法返回 `std::size_t`，通常为 64 位无符号整数。于是会出现这样的问题：

```cpp
for (int i = 0; i < v.size() - 1; i++) {
    // 如果 v.size() = 0，相减之后得到的其实是 2^64 - 1
    // 导致循环无法结束
}
```

另一个常见的错误，左移运算符的返回值仍然满足这个规律。所以 `1 << 33` 这样的代码会导致未定义行为。可以写作 `1LL << 33`。

### 数值溢出

所有的数据类型（如整数 `int`，浮点数 `double`）都会有自己的取值范围。当运算结果超过这个范围的时候，就会出现“溢出”，导致意料之外的结果。

不同类型的溢出行为也有所不同。

-   有符号整数：**未定义行为（UB）**。
-   无符号整数：自然溢出。（例如 32 位无符号整数，相当于结果对 $2^{32}$ 取模）
-   浮点数：实现定义，可能是产生 `inf` 等 IEEE-754 特殊值。

另外，数值转换的过程中，如果原值不能被目标类型储存，会有以下行为：

-   目标为有符号整数：实现定义，并在 C++20 起良好定义。（对 $2^N$ 取模）
-   目标为无符号整数：始终良好定义。（对 $2^N$ 取模）
-   目标为浮点数：相关精度问题由实现定义。

### 求值顺序

C++ 中，很多求值顺序都是未指定或无序的（为了描述简单，我们暂时不辨析这两个概念）。例如 `f() + g()`，标准允许先调用 `f()` 再调用 `g()`，也允许与其相反的顺序。

简单地讲，一个表达式最好需要满足以下规则，否则很容易出现未定义行为：

-   避免多次修改同一变量。单个表达式，只应该对一个变量修改至多一次。
-   避免同时读写变量。单个表达式，如果对变量进行了修改，就不要再读取它。

特别地，使用逗号分隔两个子表达式通常是安全的，它有良好的定序规则。

#### 详细规则

具体见 [求值顺序 - cppreference](https://en.cppreference.com/w/cpp/language/eval_order.html)。

一次完整的表达式求值，包含值计算和副作用两个操作。在同一个线程中，表达式的所有求值操作通过“先序”规则判定顺序。如果操作 A 先序于（sequenced before，也被翻译为“按顺序早于”）操作 B，那么在完成操作 A 以后才会开始执行操作 B。先序关系具有传递性。

如果表达式 A 先序于表达式 B，只有完成了 A 的值计算和副作用，才会开始进行 B 的值计算和副作用。

C++ 标准说明了几个确定的先序关系，详情可以参考上述链接。

绝大多数运算符，对左右操作数都是没有定序的。函数调用时，参数的求值顺序也是无序的（C++17 开始变为未指定行为）。

未定序的情况下，多次修改或者同时读写同一变量属于未定义行为。

例如这样的一个表达式 `i++ && ++i`，可以按照下文的方式来分析。（个人理解）

把表达式分为如下几个部分：

-   `i++`：求值 `A0`，副作用 `A1`。
-   `++i`：求值 `B0`，副作用 `B1`。
-   逻辑与：求值 `C0`。

用 `->` 表示先序关系，应用相关标准规则可知：

-   `A0 -> A1`。
-   `B1 -> B0`。
-   `A -> B`，`A0 -> C`，`B0 -> C`。

所以这个表达式可以完全定序，`A0 -> A1 -> B1 -> B0 -> C`，不存在未定义行为。

相对地，`i++ + i` 这样的表达式也可以分析出是未定义行为。

### 杂项

#### 运算符优先级

见 [C++ 运算符优先级 - cppreference](https://en.cppreference.com/w/cpp/language/operator_precedence.html)。

#### “表达式”和“语句”

表达式（Expression）和语句（Statement）是两个可能被混淆的概念。

表达式用于计算并一个值，例如以下的几个表达式：

```cpp
a + b  // 简单表达式
(a - b) * ((a + b * c) << 2)  // 表达式可以嵌套和组合
2 * sqrt(2)  // 函数调用也是表达式
```

语句用于执行操作、控制程序运行等。它没有返回值。例如以下的几个语句：

```cpp
int x{100};  // 定义变量
for (int i = 0; i < 100; i++) {  // 循环语句
    if (i % 9 == 2)  // 条件语句
        continue;  // 控制语句
    x++;  // 执行表达式的语句
}
```

#### “短路”机制

逻辑与 `&&`、逻辑或 `||` 运算符有特殊的“短路”机制。它会先计算左侧的表达式，如果此时已经可以确定答案（`&&` 遇到 `false`，`||` 遇到 `true`），就不再计算右侧的表达式。

这个特性主要是用来方便这样的代码：

```cpp
bool flag = (index < n) && (a[index] >= 0); // 如果 index >= n，不会执行右侧导致未定义行为
```

#### 逗号运算符

可以使用逗号连接两个子表达式，其行为是依次执行这两个表达式，然后返回第二个表达式的值。

这在一些情况下可以方便书写。例如：

```cpp
// 尽管 for 循环的这个位置只能执行一条语句，但是可以用逗号表达式依次执行多个逻辑。
for (int i = 0; i < n; i++, cnt++) {}
```

#### 三目运算符

三目运算符可以执行条件判断，在一些情况下可以方便书写。

```cpp
int x = (n >= 0 ? 5 : 2);
// 等价于
int x;
if (n >= 0) { x = 5; }
else { x = 2; }
```

#### 除法优化

对于计算机而言，取模和除法是极其耗时的操作。幸运的是，编译器可以对固定模数除法、取模进行大幅度优化。将除数声明为 `constexpr` 或者 `const`，开启编译器 O2 优化，可以大幅提升除法效率。对于浮点数除以固定值，可以先计算出来这个数的倒数，然后化为乘法计算。

```cpp
constexpr int mod = 998244353;  // constexpr 也可以换成 const
x % mod;  // 编译器可以进行优化
// 浮点数
for (int i = 0; i < n; i++) arr[i] /= 10;
for (int i = 0; i < n; i++) arr[i] *= 0.1;  // 更快
```

## 指针和引用

C++ 对象在内存上的存储，位于一个连续的地址空间。“指针”就是用于描述一个对象的地址。

可以把内存理解成一个大型的数组，“指针”存储的数据就是这个数组的下标（显然这是不严谨的，因为内存中可以存储不同类型的对象）。可以通过指针来读写对象。

### 指针基础

`T *p` 标识一个指向 `T` 类型对象的指针，名称为 `p`。接下来，通过 `*p` 可以访问 `p` 指向的元素（可以进行读写）。

`&x` 表示对 `x` 取地址，即获取一个指向 x 的指针。

例如以下示例：

```cpp
int x{100};
int *p = &x; // p 现在指向 x
*p = 24; // 通过指针间接修改
std::cout << x << '\n'; // 输出 24
```

类型 `T` 的部分可以包含 `const` 这样的修饰符，可以避免通过这个指针修改对象。

可以在星号后面添加 `const`，表示不可以修改“这个指针指向谁”。

例如：

```cpp
int x{10}, y{10};

int const *p1 = &x; // 等价于 const int *p1_
int * const p2 = &x;

*p1 = 100; // 错误！不能通过指针修改 const int
p1 = &y; // 现在 p1 指向 y
*p2 = 100; // 修改 x 的值
p2 = &y; // 错误！不能修改 p2 表示的地址。
```

指针必须指向一个合法的对象，并且是兼容的类型，否则对它解引用（`*p`）是未定义的。

### 常见的不可解引用指针

#### nullptr

C++ 使用 `nullptr` 作为空指针常量，语义上表示指针不指向任何元素。等于 `nullptr` 的指针不可解引用。

#### 悬空指针

当一个对象被销毁之后，指向它的指针就会变成悬空指针。一类典型的悬空指针是通过函数返回局部变量的指针。例如：

```cpp
int *f() {
    int tmp = 10;
    return &tmp;
}

int *p = f();
// 此时对 p 解引用，指向一个被销毁的局部变量，是未定义行为。
```

#### 无效指针

当一个指针指向无效的地址（通常是由于未初始化），对它解引用也是未定义的。

### 指针算术

指针可以进行一些简单的算术运算，如下：

-   指针加/减整数：将指针向前或者向后移动若干个元素。
-   指针减指针：计算它们间隔几个元素。
-   下标访问：`p[n]` 等价于 `*(p + n)`。

指针算术的单位始终是完整元素，而非字节。指针算术必须在同一个数组上进行（运算数的指针、结果的指针等），否则行为未定义。特别地，对于大小为 n 的数组，指向 a[n] 的指针也合法（尾后指针），但是不可解引用。

示例：

```cpp
int arr[100]{}; // 创建一片连续内存
int *p = &arr[5];
int *p1 = p + 5; // 指向 a[10]
int *p2 = p - 3; // 指向 a[2]
int dis = p1 - p2; // 等于 8
int item = p[9]; // a[14] 对应的值为 0
```

指针算术过程，涉及的指针必须处于同一个数组中，否则行为未定义。

### （左值）引用

“引用”在本质上和指针类似，也是通过记录内存地址来关联到另一个对象。不同的是，引用：

-   无需显式解引用。
-   无法修改绑定到哪个对象。
-   必须在初始化时绑定。

例如以下代码：

```cpp
int x = 100;
int &y = x; // 定义一个 x 的引用，名为 y
std::cout << y; // 可以像一个整数一样直接使用 y
y = 10; // x 也被修改为 10
```

引用的类型也可以带有 `const` 修饰，和对应的指针相同，不能通过这个引用来修改原对象。特别地，`const T &` 可以绑定到一个右值（如字面量等）。

很多情况下，对于比较大的对象，我们会使用常量引用来传递参数，减少一次复制的开销。

```cpp
void print(const std::string &s) {
    std::cout << s << '\n';
}
```

### 动态内存分配

在之前，我们提到了“动态存储期”这一概念。这类对象不同于自动存储期，可以有很长的生命周期，不会自动释放，直到被用户显式销毁。

在 C++ 中，可以使用 `new` 创建动态对象，使用 `delete` 释放。具体用法如下：

```cpp
#include <iostream>

auto f() -> int * {
    return new int{5};  // 创建动态对象，返回一个指针
}

auto main() -> int {
    auto ptr = f();  // 动态对象的指针可以跨函数传递
    std::cout << *ptr << '\n';
    delete ptr;  // 必须释放，否则会导致内存泄漏
}
```

一个动态对象，必须在将来的某个时刻进行释放，并且仅能释放恰好一次。如果没有释放，将会导致内存泄漏，浪费大量内存。如果释放多次，则行为未定义。释放内存后再次访问，行为未定义。

这个对象将会按照特定方式初始化：

-   `new int`：默认初始化，**将会持有不确定值**。
-   `new int{5}`：列表初始化。如果花括号为空则是值初始化，均为安全的。
-   `new int(5)`：直接初始化。

可以使用 `new[]` 和 `delete[]` 来动态分配数组。动态分配的数组，大小可以是一个变量。

```cpp
#include <iostream>

auto f(int size) -> int * {
    return new int[size];  // 动态分配内存
    // 此时的数组包含不确定值！
    // 如果希望自动清零，可以使用 new int[100]{}
}

auto main() -> int {
    int n = 100;
    auto arr = f(n);
    arr[0] = arr[1] = 1;
    for (int i = 2; i < n; i++) {
        arr[i] = (arr[i - 1] + arr[i - 2]) % 998'244'353;
    }
    std::cout << arr[n - 1] << '\n';

    // 动态分配数组，必须使用 delete[] 释放
    delete[] arr;
}
```

## 数组

数组用于存储多个相同类型、在内存上连续排布的对象。

使用如下方式定义一个数组。

```cpp
int constexpr size = 100;
int arr[size]{};  // 自动清零
```

数组的大小必须是一个正整数，且是编译期常量。通常情况下，如果希望使用变量作为数组大小，这个变量必须标记为 `constexpr`（常量表达式），或者含有常量值的 `const` 变量。

尽管标准不允许，很多编译器还是提供了扩展，允许变量值作为数组大小，称为变长数组（VLA）。

```cpp
#include <iostream>

auto main() -> int {
    int n; std::cin >> n;
    int vla[n];  // 非标准行为！
    // VLA 只能拥有自动存储期

    vla[0] = 1;
    for (int i = 1; i < n; i++) {
        vla[i] = vla[i - 1] + 1;
    }
    std::cout << vla[n - 1] << '\n';  // 输入 100，输出 100
}
```

这个代码在 GCC 中是允许的。如果希望观察标准行为，请使用 `-pedantic` 编译选项，对这类编译器扩展给出警告。

很多情况下，数组都会隐式转换为指针。转换后的指针指向数组的首个元素，即 `&a[0]`。

这种转换的出现频率很高，除非正在在作为一个“实体”（例如 `sizeof`，`decltype` 的操作数），或者作为一个左值（例如正在进行取地址）。甚至就连数组的下标访问，本质上也是指针算术。

例如，这些很常用的操作，就涉及数组到指针的转换。

```cpp
std::sort(a, a + n);  // 均转换成指针类型

// 第一个参数转换为指针，但是最后一个参数取的是数组的大小
std::memset(a, 0, sizeof(a));
```

另一个问题是，数组通过函数参数传递，往往实际上传递的也是指针。

```cpp
auto f(int a[3]) -> void {
    static_assert(std::is_same_v<int *, decltype(a)>);
}
```

在这里，我们期望的可能是，数组的元素被逐一复制并传递，但是实际上，这是在传递一个指针，在函数内部的修改会影响到外部数组。这很不符合直觉，所以不推荐使用数组作为函数参数。

数组不能作为函数返回值。以下代码不能通过编译。

```cpp
auto f() -> int[3] { return {1, 2, 3}; }
int(g())[3] { return {1, 2, 3}; }  // 前置类型、后置类型都不行
```

数组不能进行复制（赋值/初始化另一个数组），只能使用 `memcpy` 和 `std::copy` 这些函数操作。但特别地，这不会影响到包含数组的结构体。

```cpp
int a[3]{};
int b[3] = a;  // 错误！

struct S { int a[3]; };
S s1{};
S s2 = s1;  // 正确
```

由于数组存在这些缺陷，在这些场景下，建议使用 `std::array` 来替代。使用以下方式，可以定义一个 int 类型的数组，包含 20 个元素：

```cpp
std::array<int, 20> a;
```

`std::array` 可以进行传参、返回、赋值等操作，都是通过逐个元素复制。如果不希望复制，可以通过显式传递引用来避免。

多维数组可以通过嵌套 `std::array` 代替。

```cpp
std::array<std::array<int, 20>, 10> a;
// 相当于
int a[10][20];
```

`std::array` 不能隐式转换为指针，可以使用 `arr.data()` 或者 `&arr[0]` 获取指针。

## 函数

C++ 使用函数，可以把一段代码封装在一起，共同实现一个功能，进行一个计算。

### 基础知识

函数的基本用法，大家都已经很熟悉了，在这里不做讲述。

```cpp
int square(int x) {
    return x * x;
}

square(5); // 25
```

C++11 起，可以后置标注函数的返回值。这在编写一些使用模板的代码时会有帮助，并且可能更加美观。

```cpp
auto square(int x) -> int {
    return x * x;
}
```

C++14 起，返回值类型可以省略（仅使用 `auto`）。

很多情况下，在传递函数参数的过程中，可以使用聚合初始化来简化代码，无需具体写出类型。

```cpp
struct AVeryLongClassName {
    int a, b;
};

auto f(AVeryLongClassName x) -> void {
    std::cout << x.a << ' ' << x.b << '\n';
}
```

使用时，可以直接传入一个花括号包裹的初始化列表，不需显式写出类型。在这个场景下，可以自动推导出正确类型 `AVeryLongClassName`。

```cpp
f({2, 3});  // 输出 2 3
```

如果函数中的某个参数没有被使用，可以只写类型、不写参数名，来抑制编译器警告。

```cpp
int f(int x, int) { return x + 1; }
// 使用：
f(2, 3);  // 3
```

函数可以先声明，再在后面进行定义。

```cpp
int f(int x);

// ...
int f(int x) { return x + 1; }
```

### 函数重载

有些时候，我们可能会希望对多个类型实现类似功能，这种情况下就可以使用函数重载来实现，即允许多个函数拥有同一个名字。

```cpp
int square(int x) { return x * x; }  // (1)
double square(double x) { return x * x; }  // (2)

square(3);  // 调用重载 (1)
square(5.0);  // 调用重载 (2)
```

当调用存在重载的函数时，会通过重载决议判断实际调用哪一项。具体规则十分复杂，可以参考 [cppreference](https://en.cppreference.com/w/cpp/language/overload_resolution.html)。

简单来讲，需要满足以下要求：

-   首先，保证参数个数正确，并且模板推导成功、每个参数都可以隐式转换为相应类型。
-   对于这些可行项，按照以下优先级选择：
    1. 参数精确匹配。（允许左值到右值转换、限定符转换等简单转换）
    2. 只需使用标准转换，其中提升（如 `int` -> `long long`）优于其他转换（如 `double` -> `int`）。
    3. 需要用户定义的转换。（这允许从花括号包裹的初始化列表，转换为类类型）

对于相同优先级的，不带模板的函数优于带有模板的，函数模板之间按照特化程度比较。

如果无法判断两个重载的优先级，则编译错误。

### 默认参数

在函数声明中，可以为参数指定默认值，使得调用时可以省略部分参数。默认参数必须从参数列表的右侧开始连续指定。

```cpp
void print(int value, int base = 10, int width = 8) {}

print(42, 16, 4);
print(42, 16);    // 等价于 print(42, 16, 8)
print(42);        // 等价于 print(42, 10, 8)
```

存在默认参数的函数，会向重载决议添加多个重载项，例如上文的 `print` 会包括 `print(int)`、`print(int, int)` 和 `print(int, int, int)`。需要小心处理它和其他函数重载的潜在冲突。

### 重载运算符

C++ 允许重载运算符，允许自定义类型之间使用运算符进行操作，调用指定的函数。

定义一个重载运算符，可以使用 `operator` 关键字，形式大概相当于定义了一个叫做 `operator@` 的函数（`@` 是对应运算符）。

绝大多数运算符都可以被重载，以下是一个 `std::string` 乘以整数的重载。

```cpp
auto operator* (std::string const &s, int count) -> std::string {
    std::string res{};
    for (int i = 0; i < count; i++) res += s;
    return res;
}

// 使用
std::string s{"Hello"};  // 必须先转为 std::string
std::cout << s * 5 << '\n';
```

但是需要注意，重载运算符的操作数，不能全为内置类型，（例如这里包含一个 `std::string` 就是合法的）。

也可以在类的定义中，通过成员函数重载运算符（见相关章节）。

### 回调函数

有些时候，函数可以作为另一个函数的参数。这允许代码表达更加丰富的逻辑。

例如，我们有以下的两个需求：

-   找到 $[1, n]$ 的所有偶数，输出到控制台。
-   找到 $[1, n]$ 的所有偶数，存储到一个列表中。

这两个需求很明显十分接近，但是想要使用一个函数来实现，还是有一定的困难。事实上，我们可以提取一个共用的逻辑：找到该范围的所有偶数，通过某种方式提交结果。

那么我们便可以通过这种方式实现：传入整数 `n` 和另一个函数 `f`，每遇到一个偶数 `x`，通过调用 `f(x)` 提交这个答案。

我们使用 Python 语言来表达这个逻辑，因为 C++ 的类型系统可能比较复杂。如果你不了解 Python，可以看成伪代码结合注释理解。

```python
def find_even(n, f):  # 实现函数
    for i in range(1, n + 1):  # 遍历 [1, n] 区间
        if i % 2 == 0:
            f(i)  # 偶数，提交答案


def to_console(x):  # 输出到控制台
    print(x)


res = []  # 结果列表
def to_list(x):  # 输出到 res 列表
    res.append(x)

find_even(20, to_console)  # 使用
find_even(20, to_list)
```

想要在 C++ 中使用函数作为参数，可以考虑以下的方案。

#### 模板

**这是最推荐的方式**，通过模板，可以让函数接收任意类型的参数，自然包括函数。

这种方式不会有任何运行时的开销，并且可以完美支持下文提到的仿函数。

模板的相关知识会在后续章节讲解。

```cpp
template <typename T>
void find_even(int n, T f) {
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) f(i);
    }
}
```

#### 函数指针

在 C++ 中，可以让一个指针指向函数，称为函数指针。可以通过函数指针来调用这个函数。以下代码展现了函数指针的使用。

```cpp
#include <iostream>
#include <random>

int square(int x) {
    return x * x;
}

int cube(int x) {
    return x * x * x;
}

auto main() -> int {
    std::mt19937 random{std::random_device{}()};

    using FuncPointer = int (*)(int);  // 类型表示法：返回值 (*)(参数列表)
    FuncPointer ptr{};
    if (random() % 2 == 1) {  // 随机选择一个
        ptr = &cube;
    } else {
        ptr = square;  // 即使不使用取地址符号，函数名也会自动转换为函数指针
    }

    std::cout << ptr(6) << '\n';  // 函数指针可以直接使用括号调用，也可以先 (*ptr) 解引用再调用
    // 随机输出 36 或者 216
}
```

于是可以按照如下方式实现 `find_even` 函数。

```cpp
using FuncPtr = int (*)(int);
void find_even(int n, FuncPtr f) {
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) f(i);
    }
}

// 如果不使用类型别名，参数应写作 int (*f)(int)
```

这种方式无法支持仿函数和 lambda 函数，通常不推荐使用。但是函数指针也有其他的用途（例如上一个例子，以及与 C 函数交互等）。

#### std::function

`std::function` 是 C++11 起提供的一个标准库工具，可以存储一类可调用对象（函数或仿函数等），它们有相同的调用签名，即接收同样类型的参数、返回同样类型的值。

```cpp
#include <iostream>
#include <functional>

int square_impl(int x) {
    return x * x;
}

auto main() -> int {
    std::function<int(int)> square = square_impl;
    // lambda 函数也可以使用同样类型的 std::function
    std::function<int(int)> cube = [](int x) { return x * x * x; };
    std::cout << square(5) + cube(2) << '\n';  // 直接使用括号调用
    // 输出 33
}
```

`std::function` 像是适用范围更广的函数指针，在类型中只包括函数的调用签名。与之相对地，函数指针无法指向一个仿函数。

```cpp
void find_even(int n, std::function<int(int)> f) {
    for (int i = 1; i <= n; i++) {
        if (i % 2 == 0) f(i);
    }
}
```

相比于使用模板，`std::function` 有较大的运行时开销，所以在函数传参的场景下，不建议使用这个方式。它更多用于实现运行时多态。

### 仿函数、lambda 函数

C++ 的函数无法在局部定义，这带来了很大的不便。这使得跨函数共享数据，只能通过参数传递，或者全局变量。

幸运的是，我们可以在局部定义域中定义一个类，并且可以通过成员函数重载函数调用运算符，即 `a(b)`。这使得我们可以通过这种方式模拟一个函数，这就是仿函数。

```cpp
auto main() -> int {
    struct Print {
        auto operator() (/*函数参数列表*/ int x) -> void {
            std::cout << x;
        }
    } print;

    print(0);  // 使用和普通函数一致
    return 0;
}
```

仿函数的意义不仅在于可以在函数内部定义，它还是一种有状态的函数。

```cpp
auto main() -> int {
    std::vector<int> vec{1, 2, 3, 4, 5};

    int sum{};
    struct Func {
        int &sum;
        auto operator() (int x) -> void {
            sum += x;
        }
    };
    Func func{sum};

    // 对 vec 的每个对象 x，调用 func(x)
    std::for_each(vec.begin(), vec.end(), func);

    return 0;
}
```

我们通过这种方式，可以在封装函数的同时，读写局部变量。这解决了“只能通过全局变量交换数据”的问题。

但是封装仿函数还是过于麻烦，所以 C++11 引入了 lambda 函数，作为更加方便的替代。lambda 在本质上还是基于仿函数实现。

定义一个 lambda 函数，分为以下三个部分：捕获列表，参数列表，函数体。

```cpp
auto lambda = [/*捕获列表*/](/*参数列表*/) { /*函数体*/ };
```

lambda 函数的类型无法表示（编译器自动生成），必须使用 auto 来接收它。此后可以使用 decltype 获取它的类型。每个 lambda 函数的类型都互不相同。

以上文的仿函数 `Func` 为例，它其实相当于“捕获”了局部变量 `sum`，从而可以对它进行读写。lambda 函数的捕获分为两种，按值捕获、按引用捕获。参考以下示例：

```cpp
auto main() -> int {
    int a{}, b{};

    [a]() { a = 4;  /* 错误，按值捕获不能修改 */ };
    [&a]() { a = 5; /* 按引用捕获，会同步修改外部的 a */ };
    [b, &a]() { /* 可以部分变量按值捕获，部分按引用捕获 */ };
    [&]() { a = 1, b = 2; /* 当前作用域内，全部按引用捕获 */ };
    [=]() { /* 全部按值捕获 */ };
    []() { global = 2; /* 全局变量，不进行捕获也可以读写 */ };
}
```

lambda 函数和普通函数的运行时开销相同，经过内联优化后均为零开销。

借助 lambda 函数，可以完美地解决一开始提到的问题。这使得我们可以方便地在函数内部封装子函数，无需依赖全局变量。消除全局变量，可以从根源上解决“多组测试忘记清空数组”这样的问题。

C++14 起，lambda 函数的参数列表可以使用 `auto` 代替参数类型，表示这个位置允许接收任意类型的参数。这个功能本质上是基于模板实现的。C++20 起，普通函数也添加了这个功能。例如 `sort` 的比较函数，现在可以这样写。

```cpp
std::sort(v.begin(), v.end(), [](auto x, auto y) { return x.a < y.a; });
```

lambda 函数的唯一问题可能是递归比较麻烦，无法直接支持递归。我常用的方法是，额外传递一个 `self` 参数，通过它进行递归调用。

```cpp
auto fac = [&](int x) -> int { return x? x * fac(x - 1): 1; };  // 编译失败
auto fac = [&](int x, auto &self) -> int { return x? x * self(x - 1, self): 1; }  // 个人常用的写法，调用的时候需要 fac(5, fac) 的形式
std::function<int(int)> fac = [&](int x) { return x? x * fac(x - 1): 1; }  // 不推荐，有运行时开销
auto fac = [&](this auto fac, int x) { return x? x * self(x - 1): 1; }  // C++23 起，可以直接 fac(5) 调用
```

经过测试，这种函数递归写法的效率和普通函数递归没有差异。

## 类和结构体

有些情况下，我们需要处理几个关联很大的数据（例如分数的分子和分母），便可以封装一个类（class），把它们组合到一起统一管理。在 C++ 中，结构体和类几乎没有区别，通常可以混用。

### 类的基本使用

类的定义使用 `class` 或 `struct` 关键字。为了方便，我们先使用 `struct` 来定义类，后面会提到它们的区别。

```cpp
struct Frac {  // 分数
    // 数据成员
    int nume;  // 分子
    int deno;  // 分母
};
```

接下来，便可以把这个类作为一个独立的类型来使用。通过 `item.member_name` 可以访问它的数据成员。

```cpp
Frac x{};  // 值初始化
x.nume = 5;
std::cout << x.nume;  // 输出 5
```

根据先前所讲的知识，这样的简单类属于“聚合类型”，可以直接使用聚合初始化来为它提供初始值。例如 `Frac{2, 3}`，将会使用这些参数，按照声明顺序初始化类的成员。

对于一个指向 `Frac` 对象的指针，可以使用 `->` 运算符来访问成员。通常 `ptr->member` 可以看作和 `(*ptr).member` 等价。

```cpp
Frac x{3, 4};
Frac *ptr = &x;
std::cout << ptr->nume;  // 相当于 x.nume
```

### 成员函数

有些情况下，我们可能会写出这样的函数。

```cpp
void reciprocal(Frac &f) {  // 把 f 变成它的倒数
    std::swap(f.nume, f.deno);
}
// 使用：
Frac f{2, 3};
reciprocal(f);
```

C++ 支持“成员函数”（又称成员方法），从而可以通过另一种方式来定义和使用这个函数。

```cpp
struct Frac {
    // ...
    void reciprocal() {
        std::swap(nume, deno);
    }
};
// 使用：
Frac f{2, 4};
f.reciprocal();
```

成员函数会在一个对象上进行操作，可以直接通过成员的名称，来访问当前对象上的成员。例如在 `f` 上调用 `reciprocal` 成员函数时，其中的 `nume` 就是 `f.nume`，`deno` 就是 `f.deno`。

成员函数中，还可以通过关键字 `this` 获得一个指针，指向当前对象。也可以使用 `this->nume` 这样的方式来访问成员。

成员函数也可以指定为 `const`，相当于普通函数传入常量引用，具体见以下的例子。

```cpp
struct Frac {
    void print() const {
        std::cout << this->nume << '/' << this->deno << '\n';
    }
};
// 等价于
void print(const Frac &f) {
    std::cout << f.nume << '/' << f.deno << '\n';
}
```

成员函数也可以是重载运算符。调用时，将会以自身作为第一操作数，参数作为后续操作数。部分特殊的重载运算符只能是成员函数。

```cpp
struct Frac {
    auto operator+ (Frac const &other) const -> Frac {
        return {nume * other.deno + deno * other.nume, deno * other.deno};
    };
};

// 使用
Frac{1, 2} + Frac{1, 3};  // Frac{5, 6}
```

成员函数也可以先声明再定义。通过类名访问一个成员，需要使用作用域访问运算符（`::`）。
```cpp
struct Frac {
    void print() const;
};

void Frac::print() const {
    std::cout << "Frac" << std::endl;
}
```

#### 成员可访问性

从本质上讲，成员函数和普通函数几乎没有区别。那么它除了看起来比较好看，还有什么意义呢？

一些情况下，我们不希望一个对象的数据成员被外部程序修改（例如实现一个 `vector`，需要维护存储区的指针和大小，而随意修改它会严重威胁安全性）。

为了解决这个问题，C++ 引入了“成员可访问性”的概念。一个成员，可以指定在什么范围内可被访问。

-   `public`：公开。这个成员可以被外部代码访问。
-   `private`：私有。这个成员只能在当前类的内部访问。
-   `protected`：受保护。这个成员只能在当前类，或者派生类的内部访问（关于“派生类”相关知识，见下文）。

通过以下方式指定成员的可访问性：

```cpp
struct A {
    int a1;  // 默认可访问性
    double a2;
private:
    char a3;  // 接下来都是 private
    long long *a4;  // private
public:
    int a5[3];  // public
};
```

默认可访问性取决于使用 `class` 还是 `struct` 关键字声明这个类。`struct` 则为 `public`，`class` 则为 `private`。

### 构造函数

构造函数是一类特殊的函数，当一个对象通过任何方式初始化的时候，会自动调用它的构造函数。构造函数负责给各个成员提供初始值。

```cpp
struct Frac {
    // ...
    Frac(int x, int y) :
            nume(x),  // 成员初始化器
            deno{y} {
        std::cout << "构造了一个 Frac 对象";
    }
};
```

声明构造函数时，函数名部分与类名相同，不能标注返回值类型。

构造函数分为成员初始化器和函数体两个部分。初始化器可以是任意初始化形式（直接初始化、列表初始化等）。初始化对象的时候，首先通过初始化器，**按照在类中的声明顺序**初始化所有成员，接下来开始执行函数体。

成员初始化器，其求值时的作用域和构造函数的函数体相同。简单来讲，它允许了以下操作：

```cpp
struct A {
    int x, y;
    A(int x, int y):
            x(x), y(y) // 括号外的 x 和 y 是成员名，里面的是参数名
    {
        // 如同在函数体中使用 x 或 y，都是指代参数名
    }
};
```

除此以外，可以在声明成员的时候提供一个默认初始化器。当没有提供初始化器的时候，将会使用这个默认初始化器进行初始化。例如：

```cpp
struct Frac {
    int nume;
    int deno = 1; // 默认成员初始化器
    Frac(int x): nume(x) {}  // deno 将会初始化为 1
};
```

既没有没有初始化器、也没有默认初始化器的成员，会被执行默认初始化。也就是说，这可能导致部分成员**持有未定义的值或错误值**，或者在部分成员无法默认初始化的情况下，导致编译错误。更加致命的是，即使值初始化外层对象，这些被默认初始化的成员也不会赋值为零。

还有人会选择在构造函数的函数体中给数据成员赋值。这种方式可行但不推荐，提供初始化器是更加安全、便捷和高效的做法，尤其是对于复杂类型的成员。

通常情况下，建议给所有的成员都在声明时提供默认初始化器，例如值初始化 `member{}` 或者提供一个默认值 `member = 0` 来规避这个问题。

同一个类可以提供多个构造函数，通过重载决议区分。

有一些构造函数具有特殊的名字和语义，具体如下：

-   `T()`：默认构造函数。用在值初始化等场合。
-   `T(const T &)`：复制构造函数。用于复制一个对象。
-   `T(T &&)`：移动构造函数。（涉及右值引用相关知识）

而且，这些构造函数通常都会被编译器自动生成，除非有成员不支持对应操作。

可以通过 `T() = default;` 这种形式来显式生成这些构造函数。

在 OI 中，很多情况都不需要给简单的结构体定义构造函数。根据聚合初始化相关规则，只有几个公开数据成员的结构体属于“聚合体”，可以直接用花括号形式初始化。详见前文相关章节。

```cpp
struct A {
    int x; double y; char z;
};
A a1{1, 2.0, 'c'}; // 正确
A a2{1, 2.0}; // 正确，等价于 {1, 2.0, '\0'}

// 函数传参
void f(A a, int x) { /*...*/ }
f({3, 4.0, '.'}, 0); // 正确
```

#### 显式构造函数

只接受一个参数的构造函数，可以用于隐式类型转换。但是我们可能并不希望这样。

```cpp
struct A {
    int x;
    A(int x): x(x) {}
};
void f(A x) { /*...*/ }

f(5); // 相当于 f(A{5});
```

这样会降低代码可读性，也会令人困惑。将构造函数声明为 `explicit` 即可避免这样的问题。标记为 `explicit` 的构造函数，不会用于函数传参、返回值、复制初始化等场景。

```cpp
struct A {
    int x;
    explicit A(int x): x(x) {}
};
void f(A x) { /*...*/ }

f(5); // 编译错误
```

建议单个参数的构造函数均使用 `explicit` 修饰，除非真的想要用于隐式转换。

以下案例可以演示 `explicit` 构造函数的重要性。

```cpp
#include <iostream>
#include <vector>

struct A {
    int x{}, y{};
    A(int x): x(x) {}  // 没有使用 explicit 修饰
    A(int x, int y): x(x), y(y) {}
};


auto main() -> int {
    std::vector<A> v;
    // vector 的 insert 可以接收一个 std::initializer_list 来插入多项
    // 此处相当于插入 A{2} 和 A{3}
    v.insert(v.begin(), {2, 3});
    std::cout << v.size() << '\n';  // 插入了 2 个元素
}
```

将单参数的构造函数设定为 `explicit`，则行为正常，只插入一个元素。这种情况下，希望插入两个元素，需要这样写：

```cpp
v.insert(v.begin(), {A{2}, A{3}});
```

#### 委托构造函数

C++11 开始支持“委托构造函数”语法，可以直接调用当前类的其他构造函数。

```cpp
struct Rectangle {
    int width{};
    int height{};

    Rectangle() = default;
    Rectangle(int size): Rectangle(size, size) {}  // 正方形
    Rectangle(int width, int height): width{width}, height{height} {}
};
```

要求有一个初始化器为当前类名，然后传入相应的参数。此时不能再包含其他的初始化器。

### 析构函数

当一个对象的生存期结束后，会自动调用它的析构函数，例如以下场景：

-   局部变量的作用域结束时。
-   静态变量在程序结束时。
-   delete 释放动态分配的对象。

析构函数按照如下方式定义：

```cpp
#include <iostream>

struct A {
    ~A() {  // 无参数、无返回值
        std::cout << "~A()" << '\n';
    }
};

auto main() -> int {
    {
        A a;
        std::cout << 1 << '\n';
    } // 此时 a 被销毁，调用析构函数
    std::cout << 2 << '\n';
}
```

输出结果：

```cpp
1
~A()
2
```

绝大多数情况下都不需要显式定义析构函数，编译器会生成一个不做任何事情的默认析构函数。在析构函数执行之后，将会依次执行所有成员的析构函数。（于生命顺序相反）

需要析构函数的场景，通常是这个类在“管理”某个资源的时候，这个资源在对象初始化时获取，在对象销毁时释放。

例如以下的场景中，就必须使用析构函数来保证内存被成功释放。

```cpp
struct DynamicArray {
    int *data = nullptr;
    DynamicArray() = default;
    DynamicArray(std::size_t size): data(new int[size]{}) {}

    ~DynamicArray() {
        delete[] data;
    }

    auto operator[] (std::size_t index) -> int & {
        return data[index];
    }
};
```

### 静态成员
静态成员是指一部分和类相关的成员，而与实际对象无关。即同一个类中，所有的静态成员共用一个值。静态成员使用 `static` 关键字声明。

静态成员的生命周期会持续到程序结束，存储在静态存储区中。

#### 数据成员
```cpp
struct S {
    static int count;  // 声明
    S() { count++; }
    ~S() { count--; }
};
int S::count = 0;  // 定义
```

以上代码展示了静态数据成员的用法，这实现了一个计数器，记录当前存在的 `S` 类型对象个数。

静态数据成员需要在类外提供一个唯一的定义。但是存在特例，`constexpr` 的数据成员可以直接声明时定义。以及 C++17 起，可以使用 `inline`，允许在大多数场景下，声明的同时定义静态数据成员。

```cpp
struct S {
    static inline int count = 0;
    static constexpr int maxCount = 10;
};
```

#### 成员函数
静态成员函数，是一类和具体实例无关的函数，无法使用 `this` 指针和其他非静态成员。

```cpp
struct S {
    static int pow(int a, int b, int mod) /*不可以加 const*/ {
        int res = 1;
        for (; b != 0; b >>= 1, a = a * a % mod) {
            if (b & 1) res = res * a % mod;
        }
        return res;
    }
};
```

显然这个快速幂函数，并不会用到对象的状态，所以可以声明为静态的。

### 嵌套类
C++ 支持嵌套类，即可以在一个类中声明其他的类。嵌套类的对象，和外层类的对象之间不发生绑定，即不可以在嵌套类中直接使用外层类的成员。

```cpp
struct Outer {
    int a, b;
    struct Inner {
        int c, d;
    };
};
```

例如这个例子中，可以使用 `Outer::Inner{}` 来创建一个嵌套类的对象。但是这个对象中只包括 `c` 和 `d` 两个数据成员，不包括 `a` 和 `b`，自然也不能使用它。

### 继承

继承是面向对象编程的重要概念，可以用于增强代码复用。在 C++ 中，可以让一个派生类继承于一个基类，然后派生类就可以获得基类的所有成员变量和方法。

继承的语法如下：

```cpp
// 基类
struct Base {
    auto f() -> void {
        std::cout << "f()\n";
    }
};

// 派生类
struct Derived : public Base {
    auto g() -> void {
        std::cout << "g()\n";
    }
};
```

在 C++ 中，使用冒号表示继承关系。基类名之前，紧接一个可访问性标识符，表示继承而来的所有成员，其可访问性不会高于这个权限。即对于基类的 `protected`/`public` 成员，存在如下规则。

-   `public`：保留原有访问权限。
-   `protected`：访问权限变为 `protected`。
-   `private`：访问权限变为 `private`。

基类 `private` 的成员，无法在派生类中访问。

如果不填写这个访问权限，则根据类的声明方式，`struct` 默认为 `public`，`class` 默认为 `private`。

在以上例子中，可以从 `Derived` 类调用继承而来的成员函数 `f()`。

```cpp
Derived d;
d.f();  // f()
d.g();  // g()
d.Base::f();  // f()，显式指定继承路径
```

以下的例子，展现了继承的更详细用法。

```cpp
class ASCIIArt {
protected:
    int size = 5;  // 图形大小
    char fillChar = '*';  // 填充字符
public:
    ASCIIArt() = default;
    ASCIIArt(int size, char fillChar) : size(size), fillChar(fillChar) {}

    auto setFill(char ch) -> void {
        fillChar = ch;
    }
};

class Square : public ASCIIArt {
public:
    Square() = default;
    Square(int size, char fillChar) : ASCIIArt(size, fillChar) {}

    auto draw() const -> void {
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                std::cout << fillChar;
            }
            std::cout << '\n';
        }
    }
};
```

在构造派生类的时候，需要调用基类的构造函数（如果没有显式指定，则会尝试调用默认构造）。在以上的例子中，构造函数 `Square(int size, char fillChar)` 的初始化器 `ASCIIArt(size, fillChar)` 就是在初始化基类，包含基类名和初始化语句。

在派生类完成析构之后，也会自动调用基类的析构函数。

```cpp
Square square(5, '*');
square.setFill('#');
square.draw();
```

派生类中的成员，会隐藏基类中的同名成员（如果有）。对于成员函数，这二者之间并不会发生重载。例如以下代码：

```cpp
struct Base {
    auto f() -> void { std::cout << "Base\n"; }
};

struct Derived : public Base {
    auto f(int) -> void { std::cout << "Derived\n"; }
};
```

在这个情况下，在 `Derived` 对象上调用成员函数 `f()` 会直接报错，而不是调用基类的实现。

可以通过这样的方式，来绘制 5 行 5 列，使用 `#` 填充的正方形。

C++ 还支持多继承，允许一个派生类继承于多个基类，获得它们的所有成员。具体方式如下：

```cpp
struct C : public A, public B {};
```

多继承可能出现“菱形继承”的问题，例如以下示意图，靠下的表示派生类：

```
   A
  / \
 B   C
  \ /
   D
```

这种情况下，D 会持有两份 A 中的数据（一份从 B 继承，一份从 C 继承），导致无法正常使用。这种情况下，可以使用虚继承来解决。

```cpp
struct A {};
struct B : virtual public A {};
struct C : virtual public A {};
struct D : public B, public C {};
```

这样，在一个 `D` 的对象中，只会保存一份 `A` 的数据。然而虚继承会引入运行时开销，并且降低可读性，所以要尽量避免菱形继承。

使用 `static_cast` 可以在派生类指针和基类指针之间互相转换。从派生类到基类指针（向上转型）总是安全的，从基类到派生类（向下转型），如果和实际的对象类型不一致，则是未定义行为。对于向下转型，更加安全的方式是下文提到的 `dynamic_cast`。对于多继承的对象，使用 `reinterpret_cast` 反而会出现问题。

### 多态

多态（Polymorphism）是面向对象编程的另一个重要概念。多态是指，基类的成员函数，在运行时可以根据实际类型，表现出不同派生类的行为。具体来讲：

-   派生类可以覆写基类的成员函数。
-   通过基类的**指针或引用**，指向派生类的对象。
-   调用某个成员函数的时候，实际调用的是被派生类覆盖的版本。
-   C++ 中，多态使用虚函数和继承机制实现。

以下是一个反例，可以说明不使用虚函数的情况下，直接用同名成员隐藏基类成员，并不能真正实现多态。

```cpp
#include <iostream>

struct Base {
    auto f() -> void {
        std::cout << "Base\n";
    }
};

struct Derived : public Base {
    // 反例：通常情况下，派生类函数不能真正“覆盖”（Override）基类函数
    auto f() -> void {
        std::cout << "Derived\n";
    }
};

auto caller(Base &obj) -> void {
    // 这里的 Base 类，和 Base::f() 函数之间静态绑定，所以输出 Base
    obj.f();
}

auto main() -> int {
    Derived obj;
    caller(obj);

    // 此时在 Derived 上调用 f()，Derived::f() 只是会“隐藏”Base::f()，输出 Derived
    obj.f();
}
```

为了实现这个需求，C++ 引入了虚函数。虚函数可以实现动态绑定，和真正意义上的“覆盖”基类方法。在基类中指定某个成员函数为 `virtual`，即可把它声明为虚函数，让它可以被覆盖。在派生类上，使用 `override` 声明，确保发生覆盖。

```cpp
struct Base {
    int x{};
    auto virtual f() const -> void { std::cout << "Base\n"; }
};

struct Derived : public Base {
    double y{};
    auto f() const -> void override { std::cout << "Derived\n"; }
};
```

如果使用后置类型声明，需要注意 `override` 关键字需要紧贴函数体的花括号，和指定 `const` 的位置不同。派生类函数想要重写基类函数，需要调用签名完全相同（参数类型、返回值类型等）。

接下来便可以使用这种动态绑定机制了。

```cpp
auto caller(Base &b) -> void {
    b.f();
}

auto main() -> int {
    Derived d;
    caller(d);  // 输出 Derived
}
```

`override` 是可选的，但是十分推荐使用，如果覆写失败会导致编译错误，不会导致更加难以排查的逻辑错误。

需要注意的是，如果发生值复制（例如把 `caller` 从引用改成传值）会导致虚函数失效，全部指向 `Base` 中的实现。

#### 虚函数的本质

每个包含虚函数的类，编译器都会为其生成虚函数表，虚函数表中会存储若干个函数指针。所有虚函数都是通过这些函数指针间接调用的，所以可能会产生一些运行时开销。对应地，非虚函数调用是直接绑定，没有额外开销。

包含虚函数的对象，开头会维护一个指针，指向属于它的虚函数表。

例如上面的例子，`Base` 对象的内存布局为：

```
[ vptr1 | x ]
  ↓
f: Base::f()
```

`Derived` 对象的内存布局为：

```
[ vptr2 | x | y ]
  ↓
f: Derived::f()
```

当 `Derived` 对象的引用转换为 `Base` 类型时，不会影响已经存储的虚表指针。通过 `Base` 类型调用虚函数时，依旧会先通过虚表指针访问对应的虚函数表，然后寻找指定的函数进行调用。对应到这个例子，就是通过 `vptr2` 得到实际指向的函数是 `Derived::f` 然后调用它。

为什么在传值时就会失效？此时会调用 `Base(Base const &)` 进行复制，而编译器生成的复制构造函数，是构造一个新的 `Base` 对象，逐个复制成员，不关心虚表指针。所以新的对象会有自己的虚表指针，指向 `Base`。这个过程又被称为“对象切片”。

#### 虚析构函数

考虑以下场景：

```cpp
struct Base {
    int id{};
    Base(int id): id(id) {}
    auto virtual f() const -> void {
        std::cout << "User id = " << id << '\n';
    }
};

struct Derived : public Base {
    std::string name;
    Derived(int id, std::string const &name): Base(id), name(name) {}
    auto f() const -> void override {
        std::cout << "User id = " << id << " name = " << name << '\n';
    }
};

auto main() -> int {
    Base *ptr = new Derived(1, "Admin");
    ptr->f();
    delete ptr;
}
```

它看起来运行得非常正常，但其实有严重的问题。

首先，要知道 `std::string` 的存储是动态分配一块内存空间，然后维护一个指针指向它。而 `std::string` 的析构函数就是用于释放这片内存。

在 `delete ptr` 执行时，会调用 `Base` 的析构函数。而 `Base` 的析构函数并不会释放 `Derived` 里面额外定义的 `name`，导致字符串的存储区不被释放，从而内存泄漏。

解决这个问题的最好办法是，把析构函数设为虚函数。这样，执行 `delete` 时就可以通过虚函数表获得正确的析构函数，然后正确释放。

#### 动态类型识别

有些时候，我们会想要把基类的指针重新转换成派生类使用。如果实际上这个对象的类型不是目标类型，则会导致未定义行为（之前说到的“向下转型”）。`dynamic_cast` 提供了一种更加安全的解决方案。

能够使用 `dynamic_cast` 向下转型，要求基类至少有一个虚函数（因为会利用编译器创建的虚表信息），通常会选择把析构函数声明为虚函数。

`dyncmic_cast` 向下转型，如果转换失败，根据转换类型不同，出现以下错误：

-   如果是指针转换，返回 `nullptr`。
-   如果是引用转换，抛出 `std::bad_cast` 异常。

```cpp
struct Base {
    virtual ~Base() = default;
};
struct Derived : public Base {};
struct Derived2 : public Base {};

Derived x{};

Base *ptr = &x;
Base &ref = x;

dynamic_cast<Derived *>(ptr);  // 转化成功
dynamic_cast<Derived2 *>(ptr);  // 返回 nullptr
dynamic_cast<Derived2 &>(ref);  // 抛出异常
```

#### 纯虚函数

基类的虚函数，可以不提供默认实现，此时被称为“纯虚函数”。包含纯虚函数的类被称为抽象类，不能直接实例化（创建这个类型的对象）。

```cpp
struct A {
    auto virtual f() -> void = 0;  // = 0 指定为纯虚函数
};
```

抽象类只能通过其派生类对象，通过指针转化来使用。

#### 总结

如果使用 C++ 的多态类型，为了安全，应该遵守以下原则：

-   始终使用 override 重写函数。
-   使用指针/引用操作对象，避免值复制。
-   基类析构函数声明为 `virtual`。
-   向下转型优先使用 `dynamic_cast`。

## 模板和编译期计算

模板是处理多类型数据的一个重要工具，可以支持一些类型不同，但是逻辑完全相同的操作。

例如，我们希望自己实现一个 `add` 函数，来计算 `(a + b) % 998244353` 的值。这看起来很简单，但其实要支持 `int`、`long long` 这样的很多类型。于是我们需要编写很多个代码一模一样的函数。

```cpp
int add(int x, int y) { return (x + y) % 998244353; }
long add(long x, long y) { return (x + y) % 998244353; }
long long add(long long x, long long y) { return (x + y) % 998244353; }
// ...
```

C++ 引入了“模板”来解决这类问题。

### 基本使用

```cpp
template <typename T>  // 模板参数
T add(T x, T y) { return (x + y) % 998244353; }
```

这段代码就定义了一个函数模板 `add`。其含义是：任取一个类型 `T`，定义一个函数 `T add(T x, T y)`。这样，我们在上文写到的这三个重载，就分别是 `T` 取 `int`，`long` 和 `long long` 的情况。`T` 可以换成任意类型。

调用这个函数，使用以下方式：

```cpp
int ans = add<int>(1, 2);  // 显式指定，T 取 int
int ans2 = add(0LL, 3LL);  // 模板参数可以自动推导，T 取 long long
```

每次真正使用函数模板的时候，都会填充对应模板参数，然后创建一个新的函数（这个过程被称为“实例化”）。模板实例化期间，才会检查里面的语句是否合法，例如此时再写一个 `add(1.0, 2.0)`（类型推导为 `double`，浮点数不能取模），就会在这个语句处报错。

平时我们使用的 `std::swap`、`std::min`、`std::sort` 这类支持多种类型的函数，都是通过函数模板实现的。

C++ 中，有很多种实体都可以带有模板。包括：

-   类
-   函数
-   类型别名（C++11 起）
-   变量（C++14 起）
-   概念（C++20 起）

例如，我们可以通过类模板来实现一个动态大小的数组。

```cpp
template <typename T>
class DynamicArray {
    T *data_{};
public:
    // 接下来使用 DynamicArray 这个类名，如果没有指定模板参数，默认为 <T>
    DynamicArray(): DynamicArray(1) {}
    DynamicArray(std::size_t size): data_(new T[size]{}) {}
    ~DynamicArray() {
        delete[] data_;
    }

    auto operator[] (std::size_t index) -> T & {
        return data_[index];
    }
};
```

接下来，可以使用 `DynamicArray<int>` 这样的方式来使用它。平时我们使用的 `std::set`、`std::vector`、`std::pair` 等类型，都是通过类模板实现。

类模板的不同特化中（模板参数不完全相同），会拥有独自的静态成员。函数模板的不同特化中，也会拥有独自的静态变量。

### 常量表达式

在进一步讲解之前，我们需要了解 `constexpr`（常量表达式，Constant Expression）这一概念。`constexpr` 是 C++11 引入的关键字，声明可以编译期求值的变量、函数。

#### constexpr 变量

很多情况下，一些值在编译期即可确定，这种变量可以使用 `constexpr` 来修饰。

请注意 `constexpr` 和 `const` 是不同的。`const` 只是表示这个变量的值在初始化之后不可变，但是这个值可以是运行时确定的。

很多情况下，我们都需要填写一个 `constexpr` 的值。（例如数组的大小，例如后文要提到的模板参数）

```cpp
constexpr int size = 100;
int array[size];           // 合法，数组大小必须是编译期常量
```

#### constexpr 函数

constexpr 函数是可以在编译期求值的函数，即如果它的参数都是可以在编译期计算的，那么它的求值也将在编译期进行。

这个概念是 C++11 引入的，在接下来的每个版本，都允许 constexpr 函数执行更多的操作，使其更加可用。开始时的 constexpr 函数，除了一条返回语句外，不允许其他语句；C++20 起甚至可以使用 new 和 delete。

```cpp
int constexpr pow10(int x) {  // C++14 起
    int result = 1;
    for (int i = 0; i < x; i++) result *= 10;
    return result;
}

constexpr int x = 3;
int a[pow10(x)];  // 可以用作数组大小
```

### 非类型模板参数

模板参数可以不是类型，可以是具体的值。

```cpp
template <int x, int y>
struct Mul {
    static constexpr int value = x * y;
};
```

整数、枚举和指针可以是模板参数。C++20 起，可以使用浮点数、简单的类类型。

非类型的模板参数，必须填入一个编译期常量。

模板参数和函数参数的行为十分接近，同样支持默认参数。

```cpp
template <typename T = int, std::size_t size = 3>
struct Array { /*...*/ };

// 使用
Array a1{};  // Array<int, 3>（C++17 起）
Array<> a1{};  // Array<int, 3>
Array<double> a2{};  // Array<double, 3>
```

### 模板特化

有些情况下，我们可能会希望，为特定模板参数提供定制实现，这种情况下就可以使用模板特化。

模板特化分为以下两种：

-   全特化，所有的模板参数都指定一个固定类型。
-   偏特化，只有部分模板参数指定了特定类型，仍然包含模板。

类型特征（Type traits，有时称为类型萃取）是模板特化的最常见用途。我们可以通过模板来获取关于一个类型的信息，是否为整数，是否为指针，是否为函数……以下是通过类模板特化实现的一个 `is_integral` 来判断整数类型。这个代码属于全特化。

```cpp
template <typename T>
struct is_integral {
    static constexpr bool value = false;  // 默认不是整数
};

// 对于整数类型
template <>  // 全特化语法，必须使用 template <> 来声明
struct is_integral<int> {
    static constexpr bool value = true;  // 定制 int 的实现，它一定是整数
};

// ...对于所有整数类型特化
```

在使用的时候，便可以用 `is_integral<T>::value` 来判断 `T` 类型是否为整数。实际可以使用标准库的 `std::is_integral<T>::value` 或者 `std::is_integral_v<T>`。

使用偏特化实现的类型特征，一个典型的示例是 `is_same<T, U>` 判断两个类型是否相同。具体实现如下：

```cpp
template <typename T, typename U>
struct is_same {
    static constexpr bool value = false;  // 默认不相同
};

// 偏特化
template <typename T>
struct is_same<T, T> {
    static constexpr bool value = true;
};

// 模仿标准库 is_same_v
template <typename T, typename U>
constexpr bool is_same_v = is_same<T, U>::value;
```

实际可以使用标准库的 `std::is_same<T, U>::value` 或者 `std::is_same_v<T, U>`。

模板特化也可以在数值计算中使用，例如以下是一个编译期计算阶乘的程序。

```cpp
template <int n>
struct fac { static constexpr int value = n * fac<n - 1>::value; };

template <>  // 模板全特化
struct fac<0> { static constexpr int value = 1; };
```

### SFINAE

SFINAE（Substitution Failure Is Not An Error，替换失败不是错误）是 C++ 模板元编程的一个重要概念。

在重载决议的过程中，如果一个函数模板，由于模板替换导致无效代码（但不是严重的语法错误），编译器不会报错，而是会静默地丢弃这个候选项，考虑其他重载。

举一个例子，以下的代码实现一个函数模板，如果输入的对象有 size()、 len() 方法中的任意一个就调用它。（我们假设不会二者兼有）

```cpp
template <typename T>
auto size(T const &t) -> decltype(t.size()) {
    return t.size();
}

template <typename T>
auto size(T const &t) -> decltype(t.len()) {
    return t.len();
}
```

假设我们此时传入了一个 `std::vector`，它只有名为 `size()` 的方法。在第二个重载中，返回值处发生替换失败（没有 `len()`），根据 SFINAE 规则，第二个重载被忽略，只有第一个重载成为候选。

另一个常见的需求是，如果 `T` 满足某个条件，就启用这个重载，否则考虑其他的。标准库提供了 `std::enable_if` 模板，来实现这种“条件启用”的逻辑。

```cpp
template <bool B, typename T = void>
struct enable_if {  };

template <typename T>
struct enable_if<true, T> { using type = T; };

template <bool B, typename T = void>
using enable_if_t = typename enable_if<B, T>::type;
```

以上是 `std::enable_if` 的实现。需要传入一个布尔值 `B` 和一个类型 `T`（默认为 `void`）。具体效果：

-   若 `B` 为 `true`，在其中声明一个类型别名 `using type = T`。
-   若 `B` 为 `false`，则不声明任何类型别名。

可以按照如下的方式使用它。

```cpp
template <typename T>
auto f(T x) -> std::enable_if_t<std::is_integral_v<T>, T> {
    return x % 17;
}
```

其中 `is_integral_v<T>` 用于判断 `T` 是否为整数类型。

在这段代码中，如果传入一个整数类型，则返回值相当于 `std::enable_if_t<true, T>`，即 `T`。如果传入其他类型，返回值是 `std::enable_if_t<false, T>`，但是并没有声明这个类型，于是替换失败，被 SFINAE 忽略。

另一个常见的用法是，借助非类型模板参数。

```cpp
template <typename T, std::enable_if_t<std::is_integral_v<T>, int> = 0>
auto f(T x) -> T {
    return x % 17;
}
```

这种写法的优点是，可以不显式指定返回值类型，而是使用 `auto` 推导。这里的 `int` 也可以换成其他简单类型，例如 `bool`、`char` 等。

还有一个用法是借助默认模板参数。

```cpp
template <typename T, typename /*未命名的模板参数*/ = std::enable_if_t<std::is_integral_v<T>, int>>
auto f(T x) -> T {
    return x % 17;
}
```

但是这个方法其实存在重大缺陷。假如接下来需要一个对于浮点数启用的重载，那么就会出现：

```cpp
template <typename T, typename = /*...*/> auto f(T x) -> T {}
template <typename T, typename = /*...*/> auto f(T x) -> T {}
```

所以实际上，这两个模板的签名是相同的，都需要两个 `typename` 参数，于是编译器会认为这是同一个函数模板的重定义错误，然后报错。建议换用其他方法。

正确的重载方式（通过返回值 `enable_if`）：

```cpp
template <typename T>
auto f(T x) -> std::enable_if_t<std::is_integral_v<T>, T> {
    return x % 17;
}

template <typename T>
auto f(T x) -> std::enable_if_t<std::is_floating_point_v<T>, T> {
    return std::fmod(x, 17);
}
```

### if constexpr
正如上文所讲，希望通过 SFINAE 在编译期使用条件分支，其实是非常麻烦的，代码也十分晦涩难懂。于是 C++17 引入了 `if constexpr`，允许像编写常规代码一样，在编译期进行条件判断。

上文的取模函数，可以像这样实现：
```cpp
template <typename T>
auto f(T x) -> T {
    if constexpr (std::is_integral_v<T>) {
        return x % 17;
    } else if constexpr (std::is_floating_point_v<T>) {
        return std::fmod(x, 17);
    } else {
        static_assert(false, "不支持的类型");
    }
}
```

请注意，`if constexpr` 和运行时的 `if` 是完全不同的，不仅仅是运行时开销的差异。如果此处使用常规的 `if`，将会由于浮点数不支持 `%` 运算符取模，以及 `static_assert(false)` 而报错。甚至可以借助 `if constexpr` 让函数返回不同的类型。

```cpp
template <typename T>
auto f(T x) {
    if constexpr (std::is_integral_v<T>) {
        return x;
    } else {
        return "Hello!";
    }
}
```

### 概念（concept）和约束（requires）
C++20 引入了 concept，可以用更加现代化的方式，对函数模板的参数进行一些约束。

假设有一个函数 `f(x)`，我们希望它只能传入整数类型，或者是 GCC 的扩展类型 `__int128`。于是可以定义一个概念，来描述这个限制。

```cpp
template <typename T>
concept is_int = std::is_same_v<T, __int128> || std::is_integral_v<T>;
```

接下来我们就可以使用这个概念了。最简单的用法是直接用 `is_int<double>` 这样的方式判断一个类型是否符合这个概念，将会获得一个布尔值。更重要的是，概念可以直接写在模板参数中，来约束这个参数的类型。

```cpp
template <is_int T>  // T 必须为整数
auto f(T x) { /*...*/ }
```

这样写，编译器会保证 `T` 类型满足 `is_int` 的概念，否则会忽略这个重载。还有一种等价的写法：
```cpp
auto f(is_int auto x) { /*...*/ }
```

标准库也预定义了一些概念，例如 `std::integral<T>` 表示整数，`std::convertible_to<T, U>` 表示 `T` 可以转换为 `U`，`std::same_as<T, U>` 表示类型相同等。

#### requires
`requires` 和概念一同被引入，表达更加复杂的约束。

```cpp
template <typename T>
concept MyConcept = requires(T a, T b) {
    // requires 中可以“假设”定义若干个 T 类型的变量，然后检查操作合法性
    
    // 简单要求：检查某个表达式是否有效
    a + b;  // 必须支持加法
    a < b;  // 必须支持小于号

    // 类型要求：检查嵌套类型是否存在
    typename T::value_type;  // 必须存在这个类型

    // 复合要求：检查一个表达式，对它的返回值类型进行约束
    {a + b} -> std::convertible_to<T>;  // 加法返回值可以转化为 T
    // 这里的含义是，假设 a + b 的返回值为 U，概念 std::convertible_to<U, T> 必须成立
    {a.size()} -> std::integral;  // size() 返回值是整数
}
```
