# P7442 「EZEC-7」维护序列 题解

## 个人评价
一道并不好想的神秘思维题。

## 思路产生

想考虑 $m$ 个操作首先要考虑一个操作。

考虑正难则反，我们并不好想每一个下标对应的下一个数会是什么，但是对于每个操作，每一个数被移动到的下一个坐标。

我们先考虑操作一，令 $i$ 为操作前的下标，令 $j$ 为操作后的下标，显然有：
  - 当 $i$ 为偶数时，$j = \left\lfloor \frac{i}{2} \right\rfloor$。
  - 当 $i$ 为奇数时，$j = \left\lfloor \frac{i}{2} \right\rfloor + 2^{n-1}$。

我们把公式中的除以 $2$ 和 $2^{n-1}$ 替换成位运算则有（用 $\operatorname{lshift}$ 表示按位左移，$\operatorname{rshift}$ 表示按位右移）：
  - 当 $i$ 为偶数时，$j = i \operatorname{rshift} 1$。
  - 当 $i$ 为奇数时，$j = (i \operatorname{rshift} 1) + (1 \operatorname{lshift} (i-1))$。

如果我们认为每一个数的二进制位数都是 $n$ 位的话：

第一个式子相当于对于下标是偶数的整体向右移动了一位，把原先最结尾 $0$ 放到了首位。

第二个式子相当于对于下标是奇数的整体向右移动了一位，把原先最结尾的 $1$ 放到了结尾。

换言之，每一个操作就是让每一个下标的数去到**自己二进制位循环右移一位对应的位置**。

既然正难则反，那么每一个操作后下标对应的数就是**自己二进制位循环左移一位对应的数**。

（注：类似 `abcde` 变为 `eabcd` 的变换方式称为“循环右移”。）

那么我们继续考虑第二个操作。

由于第二个操作和第一个操作恰好奇偶性是相反的，那么实际上每一个数去的位置，就是第一个操作去的位置再异或 $1$，那么每一个操作后下标对应的数就是**自己先异或 $1$，再二进制位逆时针旋转一位对应的数**。

## 具体实现
首先观察数据，我们显然不能暴力去维护每一个操作后每一个下标对应的数。根据我们在之前发现的性质。我们可以维护一个 $cnt$ 表示需要逆时针旋转的位数，**注意** $cnt$ 达到 $n$ 就需要清零，考虑到操作二需要另外维护一个变量 $xr$ 表示需要异或上的数，由于异或满足结合率，我们是可以算出来需要整体异或上的数的。

由于我们使用了位运算，每一个操作都是 $O(1)$ 的，所以计算的时间复杂度是 $O(m)$。

## 代码实现
很多实现我口述不太清晰，配合代码理解更佳。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[35], cnt;
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m;
    cin >> n >> m;
    int xr = 0;
    for (int i = 1; i <= m; i++) {
        int op, x;
        cin >> op >> x;
        if (op == 1) {
            if (x == 1) xr ^= 1ll << cnt;
            // 统计需要异或的数，旋转 cnt 后的最后一位需要在统计结果的时候异或 1
            cnt++;
            if (cnt == n) cnt = 0;
        } else {
            int tmp = x & ((1ll << (n - cnt)) - 1); // 最后 cnt 位，我们先取出来
            cout << (((tmp << cnt) + (x >> (n - cnt))) ^ xr) << "\n";
            // 最后 cnt 位移动到开头，开头移动到结尾，别忘了异或 xr
        }
    }
}
```
