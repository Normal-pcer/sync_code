# P11059 题解
## 题目分析
题目要求求出满足以下性质的 $n$ 位数 $x$：
1. $x$ 的各位数字之和除以 $p$ 的余数尽可能小。
1. 在满足条件 1 的前提下，让 $x$ 的值尽可能小。

其中 $n\leq10^6$，要遍历所有的 $n$ 位数自然是不可能的。所以我们可以换一个角度——直接考虑各位数字之和，然后根据这个和构造出一个尽可能小的 $x$。
## 数字和
考虑一个 $N$ 位数的各位数字之和的值域。不难发现，这个值域就是闭区间 $\left[1, 9n\right]$，接下来给出一种构造，使得能够取遍这一区间。

首先，我们令 $x=10^{n-1}$，这个时候它的数位和恰好为最小值 $1$。

接下来，只需重复执行：将最低的不为 $9$ 的数位加 $1$，这个时候数位和相比于先前恰好也增加了 $1$，最后当 $x$ 的所有数位均为  $0$ 时达到最大值 $9n$。由于每一步的增量均为 $1$，这个区间内的所有整数都是能被取到的。

再考虑这个数位和模 $p$ 的余数。不难发现，当 $9n\geq p$ 时，$p$ 本身一定处于这个区间中，所以余数最小值必为 $0$；否则，这个区间中必然不会出现 $p$ 的倍数，故不可能为 $0$，最小值为仅次于 $0$ 的 $1$。
## 最小的 $x$
事实上，我们刚才的方法构造出的 $x$ 就是最小的。以下是一个大致的证明。

如果想要减小 $x$ 的某个数位，为了保证和相等，必然要同样地增加另一个数位。为了让 $x$ 的值减小，显然应该让增加的数位比减小的数位更低。

如果在 $x$ 的“前半段”（即 $1$ 后面接上连续的若干个 $0$ ）减小一个数字，如果操作了首位的 $1$，这个数便不再是 $N$ 位了，不可行；将 $0$ 进一步减少显然也是不可行的。

如果在 $x$ 的“后半段”（即一个非0数字后接上连续的若干个 $9$）减小一个数字，那么需要增加其后的一个数字，但是后面只有 $9$ 了，不能继续增加，所以也不可行。

综上所述，原构造即为最佳方案。

## AC 代码
```cpp
#include <bits/stdc++.h>

int N;                      // 答案的位数
int P;                      // 模数
char ans[1000005] = {'1'};  // 首位为"1"，确保符合 N 位数的条件
int main() {
    std::ios::sync_with_stdio(false); std::cin.tie(0); std::cin.tie(0);  // 加速输入输出
    std::cin >> N >> P;

    // i 表示所有数位上数字之和的可能值
    // 对于 N 位数，这个取值为 1(1000...0)~9*N(9999...9)
    // 不难发现这个闭区间内所有的值都可以取到
    // 故 minRemainder 恒为 1 或 0（与 9*N 和 P 的相对大小有关）
    int minRemainder = (N*9 < P);       // 记录最小的余数；这里的 true 和 false 会分别隐式转换为 1 和 0

    std::fill(ans+1, ans+N+1, '0');     // 除了首位继续保持为1，其他数位均置0

    // 处理低位
    // 这里采取低位均为 9，最后加一个 1~9 的数凑数位和的策略
    // 由于首位已经有了 1，剩余数位和为 (minRm-1)
    // 由于原先的最小余数可能为0，减一会变为负数，所以加上模数再次取模确保非负
    minRemainder = (minRemainder - 1 + P) % P;
    int nineCount = minRemainder / 9;           // 需要填充的"9"的个数
    int remainAmount = minRemainder % 9;        // 剩余的一个数字
    ans[N] = '\0';                              // 字符串结束
    for (int i = N-1; i >= N - nineCount; i--)  // 从低位到高位填充"9"
        ans[i] = '9';
    ans[N-nineCount-1] += remainAmount;         // 最后加上剩余的数，确保数位和依然为 minRemainder
    std::cout << ans << std::endl;              // 输出答案
    return 0;
}
```