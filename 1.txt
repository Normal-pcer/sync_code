.\P3695_CYaRon.cpp: In instantiation of 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::vector<CYaRonLang::Compiler::Token>]':
.\P3695_CYaRon.cpp:964:66:   required from here
  964 |                         auto [expr, next] = ExpressionNode::parse(tmp);
      |                                             ~~~~~~~~~~~~~~~~~~~~~^~~~~
.\P3695_CYaRon.cpp:1028:65: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1028 |                                     if (flag)  postfix.push_back({false, ValueNode{ValueNode::NoneValue, Token{Token::NoneTag}}});
      |                                                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from C:/msys64/ucrt64/include/c++/14.1.0/vector:66,
                 from C:/msys64/ucrt64/include/c++/14.1.0/functional:64,
                 from C:/msys64/ucrt64/include/c++/14.1.0/x86_64-w64-mingw32/bits/stdc++.h:53,
                 from .\P3695_CYaRon.cpp:5:
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1048:61: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1048 |                                 if (flag)  postfix.push_back({false, ValueNode{ValueNode::NoneValue, Token{Token::NoneTag}}});
      |                                            ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1102:50: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1102 |                                 postfix.push_back({false, ValueNode{ValueNode::Identifier, token}});
      |                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1104:50: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1104 |                                 postfix.push_back({false, ValueNode{ValueNode::Integer, token}});
      |                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1106:50: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1106 |                                 postfix.push_back({false, ValueNode{ValueNode::FloatingPoint, token}});
      |                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1108:46: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1108 |                             postfix.push_back({false, ValueNode{ValueNode::String, token}});
      |                             ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1162:38: error: use of deleted function 'CYaRonLang::Compiler::AST::ValueNode::ValueNode(const CYaRonLang::Compiler::AST::ValueNode&)'
 1162 |                         auto *node = new ValueNode{std::get<ValueNode>(x.item)};
      |                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:903:20: note: 'CYaRonLang::Compiler::AST::ValueNode::ValueNode(const CYaRonLang::Compiler::AST::ValueNode&)' is implicitly deleted because the default definition would be ill-formed:
  903 |             struct ValueNode: public ExpressionNode {
      |                    ^~~~~~~~~
.\P3695_CYaRon.cpp:903:20: error: use of deleted function 'CYaRonLang::Compiler::AST::ExpressionNode::ExpressionNode(const CYaRonLang::Compiler::AST::ExpressionNode&)'
.\P3695_CYaRon.cpp:860:17: note: declared here
  860 |                 ExpressionNode(const ExpressionNode &) = delete;
      |                 ^~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:903:20: note: use '-fdiagnostics-all-candidates' to display considered candidates
  903 |             struct ValueNode: public ExpressionNode {
      |                    ^~~~~~~~~
.\P3695_CYaRon.cpp:1162:38: note: use '-fdiagnostics-all-candidates' to display considered candidates
 1162 |                         auto *node = new ValueNode{std::get<ValueNode>(x.item)};
      |                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp: In instantiation of 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >]':
.\P3695_CYaRon.cpp:970:62:   required from here
  970 |                     auto [expr, next] = ExpressionNode::parse(TokensSubrange{it, src.end()});
      |                                         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:1028:65: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1028 |                                     if (flag)  postfix.push_back({false, ValueNode{ValueNode::NoneValue, Token{Token::NoneTag}}});
      |                                                ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1048:61: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1048 |                                 if (flag)  postfix.push_back({false, ValueNode{ValueNode::NoneValue, Token{Token::NoneTag}}});
      |                                            ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1102:50: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1102 |                                 postfix.push_back({false, ValueNode{ValueNode::Identifier, token}});
      |                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1104:50: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1104 |                                 postfix.push_back({false, ValueNode{ValueNode::Integer, token}});
      |                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1106:50: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1106 |                                 postfix.push_back({false, ValueNode{ValueNode::FloatingPoint, token}});
      |                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1108:46: error: no matching function for call to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::push_back(<brace-enclosed initializer list>)'
 1108 |                             postfix.push_back({false, ValueNode{ValueNode::String, token}});
      |                             ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1283 |       push_back(const value_type& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1283:35: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'const std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&' {aka 'const CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&'}
 1283 |       push_back(const value_type& __x)
      |                 ~~~~~~~~~~~~~~~~~~^~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:7: note: candidate: 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1300 |       push_back(value_type&& __x)
      |       ^~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1300:30: note:   no known conversion for argument 1 from '<brace-enclosed initializer list>' to 'std::vector<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType, std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType> >::value_type&&' {aka 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&'}
 1300 |       push_back(value_type&& __x)
      |                 ~~~~~~~~~~~~~^~~
.\P3695_CYaRon.cpp:1162:38: error: use of deleted function 'CYaRonLang::Compiler::AST::ValueNode::ValueNode(const CYaRonLang::Compiler::AST::ValueNode&)'
 1162 |                         auto *node = new ValueNode{std::get<ValueNode>(x.item)};
      |                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:1162:38: note: use '-fdiagnostics-all-candidates' to display considered candidates
In file included from C:/msys64/ucrt64/include/c++/14.1.0/ext/alloc_traits.h:34,
                 from C:/msys64/ucrt64/include/c++/14.1.0/bits/basic_string.h:39,
                 from C:/msys64/ucrt64/include/c++/14.1.0/string:54,
                 from C:/msys64/ucrt64/include/c++/14.1.0/bitset:52,
                 from C:/msys64/ucrt64/include/c++/14.1.0/x86_64-w64-mingw32/bits/stdc++.h:52:
C:/msys64/ucrt64/include/c++/14.1.0/bits/alloc_traits.h: In instantiation of 'static constexpr void std::allocator_traits<std::allocator<_CharT> >::construct(allocator_type&, _Up*, _Args&& ...) [with _Up = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; allocator_type = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:117:30:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&]'
  117 |             _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      |             ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  118 |                                      std::forward<_Args>(__args)...);
      |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::vector<CYaRonLang::Compiler::Token>]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:964:66:   required from here
  964 |                         auto [expr, next] = ExpressionNode::parse(tmp);
      |                                             ~~~~~~~~~~~~~~~~~~~~~^~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/alloc_traits.h:536:28: error: no matching function for call to 'construct_at(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*&, CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType)'
  536 |           std::construct_at(__p, std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_iterator.h:78,
                 from C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_algobase.h:67,
                 from C:/msys64/ucrt64/include/c++/14.1.0/algorithm:60,
                 from C:/msys64/ucrt64/include/c++/14.1.0/x86_64-w64-mingw32/bits/stdc++.h:51:
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:94:5: note: candidate: 'template<class _Tp, class ... _Args> constexpr decltype (::new(void*(0)) _Tp) std::construct_at(_Tp*, _Args&& ...)'
   94 |     construct_at(_Tp* __location, _Args&&... __args)
      |     ^~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:94:5: note:   template argument deduction/substitution failed:
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h: In substitution of 'template<class _Tp, class ... _Args> constexpr decltype (::new(void*(0)) _Tp) std::construct_at(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/alloc_traits.h:536:21:   required from 'static constexpr void std::allocator_traits<std::allocator<_CharT> >::construct(allocator_type&, _Up*, _Args&& ...) [with _Up = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; allocator_type = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  536 |           std::construct_at(__p, std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:117:30:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&]'
  117 |             _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      |             ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  118 |                                      std::forward<_Args>(__args)...);
      |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::vector<CYaRonLang::Compiler::Token>]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:964:66:   required from here
  964 |                         auto [expr, next] = ExpressionNode::parse(tmp);
      |                                             ~~~~~~~~~~~~~~~~~~~~~^~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:96:17: error: use of deleted function 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType::PostfixValueType(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&)'
   96 |     -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:992:28: note: 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType::PostfixValueType(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&)' is implicitly deleted because the default definition would be ill-formed:
  992 |                     struct PostfixValueType {
      |                            ^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:992:28: error: use of deleted function 'std::variant<_Types>::variant(std::variant<_Types>&&) [with _Types = {CYaRonLang::Compiler::AST::ExpressionNode::Operator, CYaRonLang::Compiler::AST::ValueNode}]'
In file included from C:/msys64/ucrt64/include/c++/14.1.0/format:52,
                 from C:/msys64/ucrt64/include/c++/14.1.0/ostream:43,
                 from C:/msys64/ucrt64/include/c++/14.1.0/bits/unique_ptr.h:43,
                 from C:/msys64/ucrt64/include/c++/14.1.0/memory:78,
                 from C:/msys64/ucrt64/include/c++/14.1.0/x86_64-w64-mingw32/bits/stdc++.h:56:
C:/msys64/ucrt64/include/c++/14.1.0/variant:1432:7: note: 'std::variant<_Types>::variant(std::variant<_Types>&&) [with _Types = {CYaRonLang::Compiler::AST::ExpressionNode::Operator, CYaRonLang::Compiler::AST::ValueNode}]' is implicitly deleted because the default definition would be ill-formed:
 1432 |       variant(variant&&) = default;
      |       ^~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/variant:1432:7: error: use of deleted function 'constexpr std::_Enable_copy_move<false, false, false, false, _Tag>::_Enable_copy_move(std::_Enable_copy_move<false, false, false, false, _Tag>&&) [with _Tag = std::variant<CYaRonLang::Compiler::AST::ExpressionNode::Operator, CYaRonLang::Compiler::AST::ValueNode>]'
In file included from C:/msys64/ucrt64/include/c++/14.1.0/optional:45,
                 from C:/msys64/ucrt64/include/c++/14.1.0/bits/ranges_algo.h:36,
                 from C:/msys64/ucrt64/include/c++/14.1.0/algorithm:63:
C:/msys64/ucrt64/include/c++/14.1.0/bits/enable_special_members.h:305:15: note: declared here
  305 |     constexpr _Enable_copy_move(_Enable_copy_move&&) noexcept       = delete;
      |               ^~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/variant:1432:7: note: use '-fdiagnostics-all-candidates' to display considered candidates
 1432 |       variant(variant&&) = default;
      |       ^~~~~~~
.\P3695_CYaRon.cpp:992:28: note: use '-fdiagnostics-all-candidates' to display considered candidates
  992 |                     struct PostfixValueType {
      |                            ^~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:96:17: note: use '-fdiagnostics-all-candidates' to display considered candidates
   96 |     -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/alloc_traits.h: In instantiation of 'static constexpr void std::allocator_traits<std::allocator<_CharT> >::construct(allocator_type&, _Up*, _Args&& ...) [with _Up = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; allocator_type = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:117:30:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&]'
  117 |             _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      |             ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  118 |                                      std::forward<_Args>(__args)...);
      |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:970:62:   required from here
  970 |                     auto [expr, next] = ExpressionNode::parse(TokensSubrange{it, src.end()});
      |                                         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/alloc_traits.h:536:28: error: no matching function for call to 'construct_at(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*&, CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType)'
  536 |           std::construct_at(__p, std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:94:5: note: candidate: 'template<class _Tp, class ... _Args> constexpr decltype (::new(void*(0)) _Tp) std::construct_at(_Tp*, _Args&& ...)'
   94 |     construct_at(_Tp* __location, _Args&&... __args)
      |     ^~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:94:5: note:   template argument deduction/substitution failed:
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h: In substitution of 'template<class _Tp, class ... _Args> constexpr decltype (::new(void*(0)) _Tp) std::construct_at(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/alloc_traits.h:536:21:   required from 'static constexpr void std::allocator_traits<std::allocator<_CharT> >::construct(allocator_type&, _Up*, _Args&& ...) [with _Up = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; allocator_type = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  536 |           std::construct_at(__p, std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:117:30:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&]'
  117 |             _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
      |             ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  118 |                                      std::forward<_Args>(__args)...);
      |                                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:970:62:   required from here
  970 |                     auto [expr, next] = ExpressionNode::parse(TokensSubrange{it, src.end()});
      |                                         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:96:17: error: use of deleted function 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType::PostfixValueType(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&)'
   96 |     -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:992:28: note: 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType::PostfixValueType(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&)' is implicitly deleted because the default definition would be ill-formed:
  992 |                     struct PostfixValueType {
      |                            ^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:992:28: error: use of deleted function 'std::variant<_Types>::variant(std::variant<_Types>&&) [with _Types = {CYaRonLang::Compiler::AST::ExpressionNode::Operator, CYaRonLang::Compiler::AST::ValueNode}]'
.\P3695_CYaRon.cpp:992:28: note: use '-fdiagnostics-all-candidates' to display considered candidates
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:96:17: note: use '-fdiagnostics-all-candidates' to display considered candidates
   96 |     -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from C:/msys64/ucrt64/include/c++/14.1.0/vector:65:
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h: In instantiation of 'constexpr bool std::__check_constructible() [with _ValueType = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:182:4:   required from '_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*]'
  182 |         = _GLIBCXX_USE_ASSIGN_FOR_INIT(_ValueType2, _From);
      |           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:373:37:   required from 'constexpr _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
  373 |       return std::uninitialized_copy(__first, __last, __result);
      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:399:2:   required from 'constexpr _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _Allocator = allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  398 |       return std::__uninitialized_copy_a
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  399 |         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  400 |          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:676:60:   required from 'constexpr void std::vector<_Tp, _Alloc>::_M_realloc_append(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  676 |             __new_finish = std::__uninitialized_move_if_noexcept_a(
      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  677 |                              __old_start, __old_finish,
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~            
  678 |                              __new_start, _M_get_Tp_allocator());
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:123:21:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&]'
  123 |           _M_realloc_append(std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::vector<CYaRonLang::Compiler::Token>]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:964:66:   required from here
  964 |                         auto [expr, next] = ExpressionNode::parse(tmp);
      |                                             ~~~~~~~~~~~~~~~~~~~~~^~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:90:56: error: static assertion failed: result type must be constructible from input type
   90 |       static_assert(is_constructible<_ValueType, _Tp>::value,
      |                                                        ^~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:90:56: note: 'std::integral_constant<bool, false>::value' evaluates to false
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h: In instantiation of 'constexpr bool std::__check_constructible() [with _ValueType = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:182:4:   required from '_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*]'
  182 |         = _GLIBCXX_USE_ASSIGN_FOR_INIT(_ValueType2, _From);
      |           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:373:37:   required from 'constexpr _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
  373 |       return std::uninitialized_copy(__first, __last, __result);
      |              ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:399:2:   required from 'constexpr _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _Allocator = allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  398 |       return std::__uninitialized_copy_a
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  399 |         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  400 |          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:676:60:   required from 'constexpr void std::vector<_Tp, _Alloc>::_M_realloc_append(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  676 |             __new_finish = std::__uninitialized_move_if_noexcept_a(
      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  677 |                              __old_start, __old_finish,
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~            
  678 |                              __new_start, _M_get_Tp_allocator());
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:123:21:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&]'
  123 |           _M_realloc_append(std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:970:62:   required from here
  970 |                     auto [expr, next] = ExpressionNode::parse(TokensSubrange{it, src.end()});
      |                                         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:90:56: error: static assertion failed: result type must be constructible from input type
   90 |       static_assert(is_constructible<_ValueType, _Tp>::value,
      |                                                        ^~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:90:56: note: 'std::integral_constant<bool, false>::value' evaluates to false
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h: In instantiation of 'constexpr void std::_Construct(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:120:21:   required from 'constexpr _ForwardIterator std::__do_uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*]'
  120 |             std::_Construct(std::__addressof(*__cur), *__first);
      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:371:30:   required from 'constexpr _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
  371 |         return std::__do_uninit_copy(__first, __last, __result);
      |                ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:399:2:   required from 'constexpr _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _Allocator = allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  398 |       return std::__uninitialized_copy_a
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  399 |         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  400 |          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:676:60:   required from 'constexpr void std::vector<_Tp, _Alloc>::_M_realloc_append(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  676 |             __new_finish = std::__uninitialized_move_if_noexcept_a(
      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  677 |                              __old_start, __old_finish,
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~            
  678 |                              __new_start, _M_get_Tp_allocator());
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:123:21:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&]'
  123 |           _M_realloc_append(std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::vector<CYaRonLang::Compiler::Token>]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:964:66:   required from here
  964 |                         auto [expr, next] = ExpressionNode::parse(tmp);
      |                                             ~~~~~~~~~~~~~~~~~~~~~^~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:115:28: error: no matching function for call to 'construct_at(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*&, CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType)'
  115 |           std::construct_at(__p, std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:94:5: note: candidate: 'template<class _Tp, class ... _Args> constexpr decltype (::new(void*(0)) _Tp) std::construct_at(_Tp*, _Args&& ...)'
   94 |     construct_at(_Tp* __location, _Args&&... __args)
      |     ^~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:94:5: note:   template argument deduction/substitution failed:
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h: In substitution of 'template<class _Tp, class ... _Args> constexpr decltype (::new(void*(0)) _Tp) std::construct_at(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:115:21:   required from 'constexpr void std::_Construct(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}]'
  115 |           std::construct_at(__p, std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:120:21:   required from 'constexpr _ForwardIterator std::__do_uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*]'
  120 |             std::_Construct(std::__addressof(*__cur), *__first);
      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:371:30:   required from 'constexpr _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
  371 |         return std::__do_uninit_copy(__first, __last, __result);
      |                ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:399:2:   required from 'constexpr _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _Allocator = allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  398 |       return std::__uninitialized_copy_a
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  399 |         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  400 |          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:676:60:   required from 'constexpr void std::vector<_Tp, _Alloc>::_M_realloc_append(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  676 |             __new_finish = std::__uninitialized_move_if_noexcept_a(
      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  677 |                              __old_start, __old_finish,
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~            
  678 |                              __new_start, _M_get_Tp_allocator());
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:123:21:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&]'
  123 |           _M_realloc_append(std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::vector<CYaRonLang::Compiler::Token>]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:964:66:   required from here
  964 |                         auto [expr, next] = ExpressionNode::parse(tmp);
      |                                             ~~~~~~~~~~~~~~~~~~~~~^~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:96:17: error: use of deleted function 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType::PostfixValueType(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&)'
   96 |     -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:96:17: note: use '-fdiagnostics-all-candidates' to display considered candidates
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h: In instantiation of 'constexpr void std::_Construct(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:120:21:   required from 'constexpr _ForwardIterator std::__do_uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*]'
  120 |             std::_Construct(std::__addressof(*__cur), *__first);
      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:371:30:   required from 'constexpr _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
  371 |         return std::__do_uninit_copy(__first, __last, __result);
      |                ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:399:2:   required from 'constexpr _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType*; _Allocator = allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  398 |       return std::__uninitialized_copy_a
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  399 |         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  400 |          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:676:60:   required from 'constexpr void std::vector<_Tp, _Alloc>::_M_realloc_append(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>]'
  676 |             __new_finish = std::__uninitialized_move_if_noexcept_a(
      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  677 |                              __old_start, __old_finish,
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~            
  678 |                              __new_start, _M_get_Tp_allocator());
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:123:21:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&]'
  123 |           _M_realloc_append(std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::vector<CYaRonLang::Compiler::Token>]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:964:66:   required from here
  964 |                         auto [expr, next] = ExpressionNode::parse(tmp);
      |                                             ~~~~~~~~~~~~~~~~~~~~~^~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:119:7: error: use of deleted function 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType::PostfixValueType(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::vector<CYaRonLang::Compiler::Token> >(const std::vector<CYaRonLang::Compiler::Token>&)::<lambda()>::PostfixValueType&&)'
  119 |       ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:119:7: note: use '-fdiagnostics-all-candidates' to display considered candidates
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h: In instantiation of 'constexpr void std::_Construct(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:120:21:   required from 'constexpr _ForwardIterator std::__do_uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*]'
  120 |             std::_Construct(std::__addressof(*__cur), *__first);
      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:371:30:   required from 'constexpr _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
  371 |         return std::__do_uninit_copy(__first, __last, __result);
      |                ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:399:2:   required from 'constexpr _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _Allocator = allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  398 |       return std::__uninitialized_copy_a
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  399 |         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  400 |          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:676:60:   required from 'constexpr void std::vector<_Tp, _Alloc>::_M_realloc_append(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  676 |             __new_finish = std::__uninitialized_move_if_noexcept_a(
      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  677 |                              __old_start, __old_finish,
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~            
  678 |                              __new_start, _M_get_Tp_allocator());
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:123:21:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&]'
  123 |           _M_realloc_append(std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:970:62:   required from here
  970 |                     auto [expr, next] = ExpressionNode::parse(TokensSubrange{it, src.end()});
      |                                         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:115:28: error: no matching function for call to 'construct_at(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*&, CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType)'
  115 |           std::construct_at(__p, std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:94:5: note: candidate: 'template<class _Tp, class ... _Args> constexpr decltype (::new(void*(0)) _Tp) std::construct_at(_Tp*, _Args&& ...)'
   94 |     construct_at(_Tp* __location, _Args&&... __args)
      |     ^~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:94:5: note:   template argument deduction/substitution failed:
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h: In substitution of 'template<class _Tp, class ... _Args> constexpr decltype (::new(void*(0)) _Tp) std::construct_at(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:115:21:   required from 'constexpr void std::_Construct(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}]'
  115 |           std::construct_at(__p, std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:120:21:   required from 'constexpr _ForwardIterator std::__do_uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*]'
  120 |             std::_Construct(std::__addressof(*__cur), *__first);
      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:371:30:   required from 'constexpr _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
  371 |         return std::__do_uninit_copy(__first, __last, __result);
      |                ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:399:2:   required from 'constexpr _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _Allocator = allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  398 |       return std::__uninitialized_copy_a
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  399 |         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  400 |          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:676:60:   required from 'constexpr void std::vector<_Tp, _Alloc>::_M_realloc_append(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  676 |             __new_finish = std::__uninitialized_move_if_noexcept_a(
      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  677 |                              __old_start, __old_finish,
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~            
  678 |                              __new_start, _M_get_Tp_allocator());
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:123:21:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&]'
  123 |           _M_realloc_append(std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:970:62:   required from here
  970 |                     auto [expr, next] = ExpressionNode::parse(TokensSubrange{it, src.end()});
      |                                         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:96:17: error: use of deleted function 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType::PostfixValueType(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&)'
   96 |     -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:96:17: note: use '-fdiagnostics-all-candidates' to display considered candidates
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h: In instantiation of 'constexpr void std::_Construct(_Tp*, _Args&& ...) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}]':
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:120:21:   required from 'constexpr _ForwardIterator std::__do_uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*]'
  120 |             std::_Construct(std::__addressof(*__cur), *__first);
      |             ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:371:30:   required from 'constexpr _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, allocator<_Tp>&) [with _InputIterator = move_iterator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*>; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
  371 |         return std::__do_uninit_copy(__first, __last, __result);
      |                ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_uninitialized.h:399:2:   required from 'constexpr _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _ForwardIterator = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType*; _Allocator = allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  398 |       return std::__uninitialized_copy_a
      |              ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  399 |         (_GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__first),
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  400 |          _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(__last), __result, __alloc);
      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:676:60:   required from 'constexpr void std::vector<_Tp, _Alloc>::_M_realloc_append(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>]'
  676 |             __new_finish = std::__uninitialized_move_if_noexcept_a(
      |                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
  677 |                              __old_start, __old_finish,
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~            
  678 |                              __new_start, _M_get_Tp_allocator());
      |                              ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   
C:/msys64/ucrt64/include/c++/14.1.0/bits/vector.tcc:123:21:   required from 'constexpr std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType}; _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; reference = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&]'
  123 |           _M_realloc_append(std::forward<_Args>(__args)...);
      |           ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_vector.h:1301:21:   required from 'constexpr void std::vector<_Tp, _Alloc>::push_back(value_type&&) [with _Tp = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType; _Alloc = std::allocator<CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType>; value_type = CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType]'
 1301 |       { emplace_back(std::move(__x)); }
      |         ~~~~~~~~~~~~^~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:999:130:   required from 'static CYaRonLang::Compiler::AST::ParseResult<CYaRonLang::Compiler::AST::ExpressionNode> CYaRonLang::Compiler::AST::ExpressionNode::parse(const T&) [with T = std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >]'
  999 |                             while (not ops.empty() and infoOf(ops.back().op).priority < infoOf(type).priority)  postfix.push_back({true, {ops.back().op}}), ops.pop_back();
      |                                                                                                                 ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
.\P3695_CYaRon.cpp:970:62:   required from here
  970 |                     auto [expr, next] = ExpressionNode::parse(TokensSubrange{it, src.end()});
      |                                         ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:119:7: error: use of deleted function 'CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType::PostfixValueType(CYaRonLang::Compiler::AST::ExpressionNode::parse<std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > > >(const std::ranges::subrange<__gnu_cxx::__normal_iterator<const CYaRonLang::Compiler::Token*, std::vector<CYaRonLang::Compiler::Token> > >&)::<lambda()>::PostfixValueType&&)'
  119 |       ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
C:/msys64/ucrt64/include/c++/14.1.0/bits/stl_construct.h:119:7: note: use '-fdiagnostics-all-candidates' to display considered candidates
